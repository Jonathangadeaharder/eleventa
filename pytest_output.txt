============================= test session starts =============================
platform win32 -- Python 3.11.9, pytest-8.3.5, pluggy-1.5.0 -- C:\Users\Jonandrop\AppData\Local\Microsoft\WindowsApps\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\python.exe
cachedir: .pytest_cache
PySide6 6.5.3 -- Qt runtime 6.5.3 -- Qt compiled 6.5.3
rootdir: C:\Users\Jonandrop\Documents\eleventa
configfile: pytest.ini
testpaths: tests
plugins: anyio-4.9.0, cov-6.1.1, mock-3.14.0, pythonpath-0.7.3, qt-4.4.0, timeout-2.3.1, xdist-3.6.1
timeout: 10.0s
timeout method: thread
timeout func_only: False
collecting ... collected 624 items

tests/core/models/test_customer.py::TestCustomerModel::test_customer_creation PASSED [  0%]
tests/core/models/test_customer.py::TestCustomerModel::test_customer_creation_defaults PASSED [  0%]
tests/core/models/test_department.py::test_department_initialization PASSED [  0%]
tests/core/models/test_department.py::test_department_initialization_with_defaults PASSED [  0%]
tests/core/models/test_department.py::test_department_initialization_some_values PASSED [  0%]
tests/core/models/test_error_models.py::TestProblemDetail::test_default_values PASSED [  0%]
tests/core/models/test_error_models.py::TestProblemDetail::test_basic_problem_detail PASSED [  1%]
tests/core/models/test_error_models.py::TestProblemDetail::test_validation_error_problem PASSED [  1%]
tests/core/models/test_error_models.py::TestProblemDetail::test_not_found_problem PASSED [  1%]
tests/core/models/test_error_models.py::TestProblemDetail::test_business_logic_problem PASSED [  1%]
tests/core/models/test_error_models.py::TestProblemDetail::test_server_error_problem PASSED [  1%]
tests/core/models/test_error_models.py::TestProblemDetail::test_partial_problem_detail PASSED [  1%]
tests/core/models/test_error_models.py::TestProblemDetail::test_model_serialization PASSED [  2%]
tests/core/models/test_error_models.py::TestProblemDetail::test_model_serialization_exclude_none PASSED [  2%]
tests/core/models/test_error_models.py::TestProblemDetail::test_model_creation_from_dict PASSED [  2%]
tests/core/models/test_error_models.py::TestProblemDetail::test_model_validation PASSED [  2%]
tests/core/models/test_error_models.py::TestProblemDetail::test_model_equality PASSED [  2%]
tests/core/models/test_error_models.py::TestProblemDetail::test_model_repr PASSED [  2%]
tests/core/models/test_inventory.py::TestInventoryMovement::test_inventory_movement_creation PASSED [  3%]
tests/core/models/test_invoice.py::TestInvoiceModel::test_invoice_creation PASSED [  3%]
tests/core/models/test_invoice.py::TestInvoiceModel::test_invoice_creation_with_all_fields PASSED [  3%]
tests/core/models/test_product.py::test_department_creation PASSED       [  3%]
tests/core/models/test_product.py::test_product_creation PASSED          [  3%]
tests/core/models/test_product.py::test_product_edge_cases PASSED        [  3%]
tests/core/models/test_product.py::test_department_edge_cases PASSED     [  4%]
tests/core/models/test_sale.py::TestSaleModels::test_sale_creation PASSED [  4%]
tests/core/models/test_sale.py::TestSaleModels::test_sale_creation_empty PASSED [  4%]
tests/core/models/test_sale.py::TestSaleModels::test_sale_item_creation PASSED [  4%]
tests/core/models/test_sale_model.py::test_saleitem_subtotal PASSED      [  4%]
tests/core/models/test_sale_model.py::test_sale_total_empty PASSED       [  4%]
tests/core/models/test_sale_model.py::test_sale_total_with_items PASSED  [  4%]
tests/core/models/test_user.py::TestUserModel::test_user_creation_defaults PASSED [  5%]
tests/core/models/test_user.py::TestUserModel::test_user_creation_with_id_and_inactive PASSED [  5%]
tests/core/services/test_cash_drawer_service.py::test_open_drawer PASSED [  5%]
tests/core/services/test_cash_drawer_service.py::test_open_drawer_already_open PASSED [  5%]
tests/core/services/test_cash_drawer_service.py::test_open_drawer_negative_amount PASSED [  5%]
tests/core/services/test_cash_drawer_service.py::test_add_cash PASSED    [  5%]
tests/core/services/test_cash_drawer_service.py::test_add_cash_drawer_not_open PASSED [  6%]
tests/core/services/test_cash_drawer_service.py::test_add_cash_negative_amount PASSED [  6%]
tests/core/services/test_cash_drawer_service.py::test_remove_cash PASSED [  6%]
tests/core/services/test_cash_drawer_service.py::test_remove_cash_drawer_not_open PASSED [  6%]
tests/core/services/test_cash_drawer_service.py::test_remove_cash_negative_amount PASSED [  6%]
tests/core/services/test_cash_drawer_service.py::test_remove_cash_insufficient_funds PASSED [  6%]
tests/core/services/test_cash_drawer_service.py::test_get_drawer_summary PASSED [  7%]
tests/core/services/test_corte_service.py::TestCorteService::test_calculate_corte_data PASSED [  7%]
tests/core/services/test_corte_service.py::TestCorteService::test_calculate_corte_data_invalid_period 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: End time must not be before start time
PASSED                                                                   [  7%]
tests/core/services/test_corte_service.py::TestCorteService::test_calculate_corte_data_repository_failure PASSED [  7%]
tests/core/services/test_corte_service.py::TestCorteService::test_calculate_sales_by_payment_type PASSED [  7%]
tests/core/services/test_corte_service.py::TestCorteService::test_calculate_starting_balance PASSED [  7%]
tests/core/services/test_corte_service.py::TestCorteService::test_register_closing_balance PASSED [  8%]
tests/core/services/test_customer_service.py::test_add_customer_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [    INFO] CustomerService:customer_service.py:50 - Added customer: John Doe (ID: 1)
PASSED                                                                   [  8%]
tests/core/services/test_customer_service.py::test_add_customer_validation_missing_name 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: Customer name cannot be empty
PASSED                                                                   [  8%]
tests/core/services/test_customer_service.py::test_add_customer_validation_invalid_email 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: Invalid email format
PASSED                                                                   [  8%]
tests/core/services/test_customer_service.py::test_update_customer_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [    INFO] CustomerService:customer_service.py:80 - Updated customer info: John Doe (ID: 1)
PASSED                                                                   [  8%]
tests/core/services/test_customer_service.py::test_update_customer_not_found PASSED [  8%]
tests/core/services/test_customer_service.py::test_update_customer_validation_empty_name 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: Customer name cannot be empty
PASSED                                                                   [  8%]
tests/core/services/test_customer_service.py::test_get_customer_by_id_success PASSED [  9%]
tests/core/services/test_customer_service.py::test_get_customer_by_id_not_found PASSED [  9%]
tests/core/services/test_customer_service.py::test_get_all_customers PASSED [  9%]
tests/core/services/test_customer_service.py::test_find_customer PASSED  [  9%]
tests/core/services/test_customer_service.py::test_delete_customer_success_no_balance 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [    INFO] CustomerService:customer_service.py:108 - Deleting 0 payment records for customer 1
2025-07-18 14:54:20 [    INFO] CustomerService:customer_service.py:115 - Deleted customer ID: 1
PASSED                                                                   [  9%]
tests/core/services/test_customer_service.py::test_delete_customer_not_found 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [ WARNING] CustomerService:customer_service.py:96 - Attempted to delete non-existent customer ID: 99
PASSED                                                                   [  9%]
tests/core/services/test_customer_service.py::test_delete_customer_with_balance PASSED [ 10%]
tests/core/services/test_customer_service.py::test_apply_payment_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [    INFO] CustomerService:customer_service.py:176 - Applied payment 10 of 100.00 to customer 00000000-0000-0000-0000-000000000001. New balance: 100.00. User ID for CreditPayment: 5 (type: <class 'int'>)
PASSED                                                                   [ 10%]
tests/core/services/test_customer_service.py::test_apply_payment_customer_not_found PASSED [ 10%]
tests/core/services/test_customer_service.py::test_apply_payment_non_positive_amount 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: Payment amount must be positive.
2025-07-18 14:54:20 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: Payment amount must be positive.
PASSED                                                                   [ 10%]
tests/core/services/test_customer_service.py::test_increase_customer_debt_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [    INFO] CustomerService:customer_service.py:204 - Increased debt for customer 1 by 25.00. New balance: -25.00
PASSED                                                                   [ 10%]
tests/core/services/test_customer_service.py::test_increase_customer_debt_customer_not_found PASSED [ 10%]
tests/core/services/test_customer_service.py::test_increase_customer_debt_non_positive_amount 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:20 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: Amount to increase debt must be positive.
2025-07-18 14:54:20 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: Amount to increase debt must be positive.
PASSED                                                                   [ 11%]
tests/core/services/test_customer_service.py::test_get_customer_payments_success PASSED [ 11%]
tests/core/services/test_customer_service.py::test_get_customer_payments_no_payments PASSED [ 11%]
tests/core/services/test_inventory_service.py::test_add_inventory_success PASSED [ 11%]
tests/core/services/test_inventory_service.py::test_add_inventory_zero_quantity PASSED [ 11%]
tests/core/services/test_inventory_service.py::test_add_inventory_negative_quantity PASSED [ 11%]
tests/core/services/test_inventory_service.py::test_add_inventory_product_not_found PASSED [ 12%]
tests/core/services/test_inventory_service.py::test_add_inventory_product_does_not_use_inventory PASSED [ 12%]
tests/core/services/test_inventory_service.py::test_adjust_inventory_success_positive PASSED [ 12%]
tests/core/services/test_inventory_service.py::test_adjust_inventory_success_negative PASSED [ 12%]
tests/core/services/test_inventory_service.py::test_adjust_inventory_zero_quantity PASSED [ 12%]
tests/core/services/test_inventory_service.py::test_adjust_inventory_negative_stock PASSED [ 12%]
tests/core/services/test_inventory_service.py::test_adjust_inventory_product_not_found PASSED [ 12%]
tests/core/services/test_inventory_service.py::test_adjust_inventory_product_no_inventory_control PASSED [ 13%]
tests/core/services/test_inventory_service.py::test_decrease_stock_for_sale_success PASSED [ 13%]
tests/core/services/test_inventory_service.py::test_decrease_stock_for_sale_product_not_found PASSED [ 13%]
tests/core/services/test_inventory_service.py::test_decrease_stock_for_sale_product_no_inventory PASSED [ 13%]
tests/core/services/test_inventory_service.py::test_decrease_stock_for_sale_insufficient_stock PASSED [ 13%]
tests/core/services/test_inventory_service.py::test_decrease_stock_for_sale_zero_quantity PASSED [ 13%]
tests/core/services/test_inventory_service.py::test_decrease_stock_for_sale_negative_quantity PASSED [ 14%]
tests/core/services/test_inventory_service.py::test_get_inventory_report PASSED [ 14%]
tests/core/services/test_inventory_service.py::test_get_low_stock_products PASSED [ 14%]
tests/core/services/test_inventory_service.py::test_get_inventory_movements_all PASSED [ 14%]
tests/core/services/test_inventory_service.py::test_get_inventory_movements_for_product PASSED [ 14%]
tests/core/services/test_invoicing_concurrency.py::test_create_invoice_integration PASSED [ 14%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_create_invoice_already_exists PASSED [ 15%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_create_invoice_customer_not_found PASSED [ 15%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_create_invoice_from_sale_success PASSED [ 15%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_create_invoice_no_customer PASSED [ 15%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_create_invoice_sale_not_found PASSED [ 15%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_determine_invoice_type PASSED [ 15%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_generate_invoice_pdf 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:21 [    INFO] InvoicingService:invoicing_service.py:344 - Generating PDF: C:\Users\Jonandrop\AppData\Local\Temp\tmp214mp3fi.pdf
2025-07-18 14:54:21 [    INFO] InvoicingService:invoicing_service.py:449 - Successfully generated PDF: C:\Users\Jonandrop\AppData\Local\Temp\tmp214mp3fi.pdf
PASSED                                                                   [ 16%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_generate_invoice_pdf_error_handling PASSED [ 16%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_get_iva_rate PASSED [ 16%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_get_next_invoice_number PASSED [ 16%]
tests/core/services/test_invoicing_service.py::TestInvoicingService::test_get_next_invoice_number_first_invoice PASSED [ 16%]
tests/core/services/test_invoicing_service_extra.py::test_generate_next_invoice_number_first PASSED [ 16%]
tests/core/services/test_invoicing_service_extra.py::test_generate_next_invoice_number_increment PASSED [ 16%]
tests/core/services/test_invoicing_service_extra.py::test_determine_invoice_type_various PASSED [ 17%]
tests/core/services/test_invoicing_service_extra.py::test_get_iva_rate_various PASSED [ 17%]
tests/core/services/test_invoicing_service_extra.py::test_create_invoice_sale_not_found PASSED [ 17%]
tests/core/services/test_invoicing_service_extra.py::test_create_invoice_already_has_invoice PASSED [ 17%]
tests/core/services/test_invoicing_service_extra.py::test_create_invoice_no_customer PASSED [ 17%]
tests/core/services/test_invoicing_service_extra.py::test_create_invoice_customer_not_found PASSED [ 17%]
tests/core/services/test_invoicing_service_extra.py::test_create_invoice_success PASSED [ 18%]
tests/core/services/test_invoicing_service_extra.py::test_create_invoice_duplicate_on_save 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:21 [ WARNING] InvoicingService:invoicing_service.py:122 - Caught error during invoice add for sale 60: ValueError - Duplicate entry in DB
PASSED                                                                   [ 18%]
tests/core/services/test_invoicing_service_extra.py::test_get_invoice_by_id_and_sale_id_and_all PASSED [ 18%]
tests/core/services/test_invoicing_service_integration.py::test_create_invoice_integration PASSED [ 18%]
tests/core/services/test_invoicing_service_integration.py::test_concurrent_invoice_creation PASSED [ 18%]
tests/core/services/test_product_service.py::test_add_product_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:67 - Adding product with code: P001
PASSED                                                                   [ 18%]
tests/core/services/test_product_service.py::test_add_product_basic_validation_fails[invalid_product0-Code cannot be empty] PASSED [ 19%]
tests/core/services/test_product_service.py::test_add_product_basic_validation_fails[invalid_product1-Description cannot be empty] PASSED [ 19%]
tests/core/services/test_product_service.py::test_add_product_basic_validation_fails[invalid_product2-Sell price must be positive] PASSED [ 19%]
tests/core/services/test_product_service.py::test_add_product_basic_validation_fails[invalid_product3-Cost price must be positive] PASSED [ 19%]
tests/core/services/test_product_service.py::test_add_product_basic_validation_fails[invalid_product4-Cost price cannot be zero] PASSED [ 19%]
tests/core/services/test_product_service.py::test_add_product_basic_validation_fails[invalid_product5-Sell price cannot be zero] PASSED [ 19%]
tests/core/services/test_product_service.py::test_add_product_duplicate_code_fails PASSED [ 20%]
tests/core/services/test_product_service.py::test_add_product_nonexistent_dept_fails PASSED [ 20%]
tests/core/services/test_product_service.py::test_update_product_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:84 - Updating product with ID: 101
PASSED                                                                   [ 20%]
tests/core/services/test_product_service.py::test_update_product_validation_fails PASSED [ 20%]
tests/core/services/test_product_service.py::test_update_product_code_conflict_fails PASSED [ 20%]
tests/core/services/test_product_service.py::test_update_product_nonexistent_fails PASSED [ 20%]
tests/core/services/test_product_service.py::test_delete_product_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:99 - Deleting product with ID: 201
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:99 - Deleting product with ID: 202
PASSED                                                                   [ 20%]
tests/core/services/test_product_service.py::test_delete_product_with_stock_fails PASSED [ 21%]
tests/core/services/test_product_service.py::test_delete_product_nonexistent 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [ WARNING] ProductService:product_service.py:102 - Attempted to delete non-existent product with ID: 999
PASSED                                                                   [ 21%]
tests/core/services/test_product_service.py::test_find_product_calls_search PASSED [ 21%]
tests/core/services/test_product_service.py::test_find_product_calls_get_all PASSED [ 21%]
tests/core/services/test_product_service.py::test_add_department_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:169 - Adding department with name: New Dept
PASSED                                                                   [ 21%]
tests/core/services/test_product_service.py::test_add_department_validation_fails[invalid_dept0-Name cannot be empty] PASSED [ 21%]
tests/core/services/test_product_service.py::test_add_department_duplicate_name_fails PASSED [ 22%]
tests/core/services/test_product_service.py::test_delete_department_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:192 - Deleting department with ID: 10
PASSED                                                                   [ 22%]
tests/core/services/test_product_service.py::test_delete_department_in_use_fails PASSED [ 22%]
tests/core/services/test_product_service.py::test_get_all_departments PASSED [ 22%]
tests/core/services/test_product_service.py::test_update_department_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:208 - Updating department with ID: 5
PASSED                                                                   [ 22%]
tests/core/services/test_product_service.py::test_update_department_validation_fails PASSED [ 22%]
tests/core/services/test_product_service.py::test_update_department_duplicate_name_fails PASSED [ 23%]
tests/core/services/test_product_service.py::test_update_department_nonexistent_fails PASSED [ 23%]
tests/core/services/test_product_service.py::test_product_service_integration 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:169 - Adding department with name: IntegrationDept
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:67 - Adding product with code: INTEG01
2025-07-18 14:54:22 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: Department 'IntegrationDept' cannot be deleted, it is used by 1 product(s).
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:99 - Deleting product with ID: 1
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:192 - Deleting department with ID: 1
PASSED                                                                   [ 23%]
tests/core/services/test_product_service.py::test_update_prices_all_products 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:227 - Fetching all products to update prices by 10%.
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:254 - Successfully updated prices for 2 products by 10%.
PASSED                                                                   [ 23%]
tests/core/services/test_product_service.py::test_update_prices_by_department 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:224 - Fetching products for department ID: 1 to update prices by -20%.
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:254 - Successfully updated prices for 1 products by -20%.
PASSED                                                                   [ 23%]
tests/core/services/test_product_service.py::test_update_prices_no_products_found_all 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:227 - Fetching all products to update prices by 10%.
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:231 - No products found to update.
PASSED                                                                   [ 23%]
tests/core/services/test_product_service.py::test_update_prices_no_products_found_department 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:224 - Fetching products for department ID: 5 to update prices by 10%.
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:231 - No products found to update.
PASSED                                                                   [ 24%]
tests/core/services/test_product_service.py::test_update_prices_invalid_percentage[invalid_percentage0] PASSED [ 24%]
tests/core/services/test_product_service.py::test_update_prices_invalid_percentage[invalid_percentage1] PASSED [ 24%]
tests/core/services/test_product_service.py::test_update_prices_invalid_percentage[invalid_percentage2] PASSED [ 24%]
tests/core/services/test_product_service.py::test_update_prices_product_with_no_sell_price 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:227 - Fetching all products to update prices by 10%.
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:254 - Successfully updated prices for 1 products by 10%.
PASSED                                                                   [ 24%]
tests/core/services/test_product_service.py::test_update_prices_rounding_and_zero_floor 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:227 - Fetching all products to update prices by 10.555%.
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:254 - Successfully updated prices for 2 products by 10.555%.
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:227 - Fetching all products to update prices by -99.5%.
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:254 - Successfully updated prices for 1 products by -99.5%.
PASSED                                                                   [ 24%]
tests/core/services/test_product_service_departments.py::test_add_department_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:169 - Adding department with name: Dept1
PASSED                                                                   [ 25%]
tests/core/services/test_product_service_departments.py::test_add_department_duplicate_name PASSED [ 25%]
tests/core/services/test_product_service_departments.py::test_get_all_departments PASSED [ 25%]
tests/core/services/test_product_service_departments.py::test_delete_department_nonexistent 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [ WARNING] ProductService:product_service.py:184 - Attempted to delete non-existent department with ID: 99
PASSED                                                                   [ 25%]
tests/core/services/test_product_service_departments.py::test_delete_department_in_use_fails PASSED [ 25%]
tests/core/services/test_product_service_departments.py::test_delete_department_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:192 - Deleting department with ID: 4
PASSED                                                                   [ 25%]
tests/core/services/test_product_service_departments.py::test_update_department_missing_id PASSED [ 25%]
tests/core/services/test_product_service_departments.py::test_update_department_not_found PASSED [ 26%]
tests/core/services/test_product_service_departments.py::test_update_department_validation_fails PASSED [ 26%]
tests/core/services/test_product_service_departments.py::test_update_department_success 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] ProductService:product_service.py:208 - Updating department with ID: 8
PASSED                                                                   [ 26%]
tests/core/services/test_receipt_generation.py::TestReceiptGeneration::test_generate_receipt_pdf_filename_format PASSED [ 26%]
tests/core/services/test_receipt_generation.py::TestReceiptGeneration::test_generate_receipt_pdf_sale_not_found PASSED [ 26%]
tests/core/services/test_receipt_generation.py::TestReceiptGeneration::test_generate_receipt_pdf_success PASSED [ 26%]
tests/core/services/test_receipt_generation.py::TestReceiptGeneration::test_generate_receipt_pdf_with_customer PASSED [ 27%]
tests/core/services/test_reporting_service.py::TestReportingService::test_get_sales_summary_by_period PASSED [ 27%]
tests/core/services/test_reporting_service.py::TestReportingService::test_get_sales_by_payment_type PASSED [ 27%]
tests/core/services/test_reporting_service.py::TestReportingService::test_get_sales_by_department PASSED [ 27%]
tests/core/services/test_reporting_service.py::TestReportingService::test_get_sales_by_customer PASSED [ 27%]
tests/core/services/test_reporting_service.py::TestReportingService::test_get_top_selling_products PASSED [ 27%]
tests/core/services/test_reporting_service.py::TestReportingService::test_calculate_profit_for_period PASSED [ 28%]
tests/core/services/test_reporting_service.py::TestReportingService::test_get_daily_sales_report PASSED [ 28%]
tests/core/services/test_reporting_service.py::TestReportingService::test_get_sales_trend PASSED [ 28%]
tests/core/services/test_reporting_service.py::TestReportingService::test_get_comparative_report PASSED [ 28%]
tests/core/services/test_reporting_service.py::test_print_report_methods[print_sales_by_period_report-ventas_por_periodo] PASSED [ 28%]
tests/core/services/test_reporting_service.py::test_print_report_methods[print_sales_by_department_report-ventas_por_departamento] PASSED [ 28%]
tests/core/services/test_reporting_service.py::test_print_report_methods[print_sales_by_customer_report-ventas_por_cliente] PASSED [ 29%]
tests/core/services/test_reporting_service.py::test_print_report_methods[print_top_products_report-top_productos] PASSED [ 29%]
tests/core/services/test_reporting_service.py::test_print_report_methods[print_profit_analysis_report-analisis_ganancias] PASSED [ 29%]
tests/core/services/test_reporting_service.py::test_print_report_failure PASSED [ 29%]
tests/core/services/test_sale_service.py::test_create_sale_success PASSED [ 29%]
tests/core/services/test_sale_service.py::test_create_sale_with_credit PASSED [ 29%]
tests/core/services/test_sale_service.py::test_get_sale_by_id PASSED     [ 29%]
tests/core/services/test_sale_service.py::test_generate_receipt_pdf PASSED [ 30%]
tests/core/services/test_user_service.py::test_add_user_with_valid_data_succeeds 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] UserService:user_service.py:52 - Creating new user: newuser
PASSED                                                                   [ 30%]
tests/core/services/test_user_service.py::test_add_user_with_existing_username_raises_error 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] UserService:user_service.py:44 - Username 'existinguser' already exists.
PASSED                                                                   [ 30%]
tests/core/services/test_user_service.py::test_add_user_with_empty_username_raises_error PASSED [ 30%]
tests/core/services/test_user_service.py::test_add_user_with_empty_password_raises_error PASSED [ 30%]
tests/core/services/test_user_service.py::test_authenticate_with_valid_credentials_succeeds 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] UserService:user_service.py:84 - Authentication successful for user: authuser
PASSED                                                                   [ 30%]
tests/core/services/test_user_service.py::test_authenticate_with_incorrect_password_returns_none 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] UserService:user_service.py:87 - Authentication failed for username 'authuser': incorrect password
PASSED                                                                   [ 31%]
tests/core/services/test_user_service.py::test_authenticate_with_nonexistent_user_returns_none 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] UserService:user_service.py:80 - Authentication failed for username 'nosuchuser': user not found or inactive
PASSED                                                                   [ 31%]
tests/core/services/test_user_service.py::test_authenticate_with_inactive_user_returns_none 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:22 [    INFO] UserService:user_service.py:80 - Authentication failed for username 'inactiveuser': user not found or inactive
PASSED                                                                   [ 31%]
tests/core/services/test_user_service.py::test_authenticate_with_empty_credentials_returns_none PASSED [ 31%]
tests/core/services/test_user_service.py::test_get_user_by_id_returns_user_when_exists PASSED [ 31%]
tests/core/services/test_user_service.py::test_get_user_by_username_returns_user_when_exists PASSED [ 31%]
tests/core/test_config.py::test_load_defaults_when_no_file PASSED        [ 32%]
tests/core/test_config.py::test_save_and_load_cycle PASSED               [ 32%]
tests/core/test_exceptions.py::test_application_error_base PASSED        [ 32%]
tests/core/test_exceptions.py::test_validation_error PASSED              [ 32%]
tests/core/test_exceptions.py::test_resource_not_found_error PASSED      [ 32%]
tests/core/test_exceptions.py::test_database_error_basic PASSED          [ 32%]
tests/core/test_exceptions.py::test_database_error_with_original PASSED  [ 33%]
tests/core/test_exceptions.py::test_authentication_error PASSED          [ 33%]
tests/core/test_exceptions.py::test_business_rule_error PASSED           [ 33%]
tests/core/test_exceptions.py::test_external_service_error_basic PASSED  [ 33%]
tests/core/test_exceptions.py::test_external_service_error_with_name PASSED [ 33%]
tests/core/utils/test_validation.py::test_validate_required_field_valid[some value-Nombre] PASSED [ 33%]
tests/core/utils/test_validation.py::test_validate_required_field_valid[123-ID] PASSED [ 33%]
tests/core/utils/test_validation.py::test_validate_required_field_valid[0-Cantidad] PASSED [ 34%]
tests/core/utils/test_validation.py::test_validate_required_field_valid[False-Activo] PASSED [ 34%]
tests/core/utils/test_validation.py::test_validate_required_field_invalid[None-Name-Name cannot be empty] PASSED [ 34%]
tests/core/utils/test_validation.py::test_validate_required_field_invalid[-Description-Description cannot be empty] PASSED [ 34%]
tests/core/utils/test_validation.py::test_validate_required_field_invalid[   -Code-Code cannot be empty] PASSED [ 34%]
tests/core/utils/test_validation.py::test_validate_positive_number_valid[value0-Precio] PASSED [ 34%]
tests/core/utils/test_validation.py::test_validate_positive_number_valid[value1-Descuento] PASSED [ 35%]
tests/core/utils/test_validation.py::test_validate_positive_number_valid[None-L\xedmite] PASSED [ 35%]
tests/core/utils/test_validation.py::test_validate_positive_number_invalid[value0-Quantity-Quantity must be positive] PASSED [ 35%]
tests/core/utils/test_validation.py::test_validate_positive_number_invalid[value1-Price-Price must be positive] PASSED [ 35%]
tests/core/utils/test_validation.py::test_validate_unique_field_not_exists PASSED [ 35%]
tests/core/utils/test_validation.py::test_validate_unique_field_exists_create PASSED [ 35%]
tests/core/utils/test_validation.py::test_validate_unique_field_exists_update PASSED [ 36%]
tests/core/utils/test_validation.py::test_validate_non_zero_quantity_valid[quantity0-venta] PASSED [ 36%]
tests/core/utils/test_validation.py::test_validate_non_zero_quantity_valid[quantity1-compra] PASSED [ 36%]
tests/core/utils/test_validation.py::test_validate_non_zero_quantity_invalid[quantity0-sale-Quantity for sale must be greater than zero] PASSED [ 36%]
tests/core/utils/test_validation.py::test_validate_non_zero_quantity_invalid[quantity1-adjustment-Quantity for adjustment must be greater than zero] PASSED [ 36%]
tests/core/utils/test_validation.py::test_validate_exists_true PASSED    [ 36%]
tests/core/utils/test_validation.py::test_validate_exists_false PASSED   [ 37%]
tests/core/utils/test_validation.py::test_validate_sufficient_stock_valid PASSED [ 37%]
tests/core/utils/test_validation.py::test_validate_sufficient_stock_invalid PASSED [ 37%]
tests/infrastructure/persistence/simple_test.py::test_simple PASSED      [ 37%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::setup_for_test PASSED [ 37%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_add_and_get_entry_by_id PASSED [ 37%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_get_entry_by_id_not_found PASSED [ 37%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_get_entries_by_date_range PASSED [ 38%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_get_entries_by_drawer_id PASSED [ 38%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_get_current_balance PASSED [ 38%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_get_current_balance_no_entries PASSED [ 38%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_is_drawer_open PASSED [ 38%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_get_today_entries PASSED [ 38%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_get_entries_by_type PASSED [ 39%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_get_last_start_entry PASSED [ 39%]
tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_get_last_start_entry_none FAILED [ 39%]
tests/infrastructure/persistence/test_credit_payment_repository.py::test_add_and_get_credit_payment PASSED [ 39%]
tests/infrastructure/persistence/test_credit_payment_repository.py::test_get_credit_payments_for_customer PASSED [ 39%]
tests/infrastructure/persistence/test_credit_payment_repository.py::test_get_for_customer_empty PASSED [ 39%]
tests/infrastructure/persistence/test_credit_payment_repository.py::test_negative_payment_amount_raises_error PASSED [ 40%]
tests/infrastructure/persistence/test_credit_payment_repository.py::TestSqliteCreditPaymentRepository::test_add_credit_payment PASSED [ 40%]
tests/infrastructure/persistence/test_customer_repository.py::test_add_customer PASSED [ 40%]
tests/infrastructure/persistence/test_customer_repository.py::test_add_customer_duplicate_cuit 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with CUIT 99887766 already exists
PASSED                                                                   [ 40%]
tests/infrastructure/persistence/test_customer_repository.py::test_add_customer_duplicate_email 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with email unique.email@example.com already exists
PASSED                                                                   [ 40%]
tests/infrastructure/persistence/test_customer_repository.py::test_get_customer_by_id 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with email test.customer@test.com already exists
FAILED                                                                   [ 40%]
tests/infrastructure/persistence/test_customer_repository.py::test_get_customer_by_id_not_found PASSED [ 41%]
tests/infrastructure/persistence/test_customer_repository.py::test_get_customer_by_cuit 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with email test.customer@test.com already exists
FAILED                                                                   [ 41%]
tests/infrastructure/persistence/test_customer_repository.py::test_get_customer_by_cuit_not_found PASSED [ 41%]
tests/infrastructure/persistence/test_customer_repository.py::test_get_all_customers FAILED [ 41%]
tests/infrastructure/persistence/test_customer_repository.py::test_update_customer 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with email test.customer@test.com already exists
FAILED                                                                   [ 41%]
tests/infrastructure/persistence/test_customer_repository.py::test_update_customer_not_found 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:repositories.py:1005 - Error updating customer: Customer with ID deba0bd7-e44d-4fa0-b8d1-985e95eb8e29 not found
PASSED                                                                   [ 41%]
tests/infrastructure/persistence/test_customer_repository.py::test_delete_customer 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with email test.customer@test.com already exists
FAILED                                                                   [ 41%]
tests/infrastructure/persistence/test_customer_repository.py::test_delete_customer_not_found PASSED [ 42%]
tests/infrastructure/persistence/test_customer_repository.py::test_search_customer_by_name PASSED [ 42%]
tests/infrastructure/persistence/test_customer_repository.py::test_get_all_customers_pagination FAILED [ 42%]
tests/infrastructure/persistence/test_customer_repository.py::test_search_customers_filtering_and_sorting 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with CUIT 1001 already exists
FAILED                                                                   [ 42%]
tests/infrastructure/persistence/test_database.py::test_database_connection PASSED [ 42%]
tests/infrastructure/persistence/test_database.py::test_session_scope_success PASSED [ 42%]
tests/infrastructure/persistence/test_database.py::test_session_scope_rollback 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:utils.py:102 - Error during session: Test exception. Rolling back.
PASSED                                                                   [ 43%]
tests/infrastructure/persistence/test_database.py::test_session_scope_rollback_data_consistency 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:utils.py:102 - Error during session: Test exception. Rolling back.
PASSED                                                                   [ 43%]
tests/infrastructure/persistence/test_database.py::test_session_scope_commit_exception_consistency 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:utils.py:96 - Error during session commit: (sqlite3.IntegrityError) UNIQUE constraint failed: test_items.id
[SQL: INSERT INTO test_items (id, name) VALUES (?, ?)]
[parameters: (2, 'duplicate')]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
2025-07-18 14:54:23 [   ERROR] root:utils.py:102 - Error during session: Database commit error: (sqlite3.IntegrityError) UNIQUE constraint failed: test_items.id
[SQL: INSERT INTO test_items (id, name) VALUES (?, ?)]
[parameters: (2, 'duplicate')]
(Background on this error at: https://sqlalche.me/e/20/gkpj). Rolling back.
PASSED                                                                   [ 43%]
tests/infrastructure/persistence/test_database_module.py::test_import_mappings_returns_models_module PASSED [ 43%]
tests/infrastructure/persistence/test_database_module.py::test_ensure_all_models_mapped PASSED [ 43%]
tests/infrastructure/persistence/test_database_module.py::test_create_all_tables_creates_model_tables PASSED [ 43%]
tests/infrastructure/persistence/test_database_module.py::test_init_db_calls_create_all PASSED [ 44%]
tests/infrastructure/persistence/test_database_operations.py::test_database_initialization PASSED [ 44%]
tests/infrastructure/persistence/test_database_operations.py::test_execute_query PASSED [ 44%]
tests/infrastructure/persistence/test_database_operations.py::test_execute_query_exception PASSED [ 44%]
tests/infrastructure/persistence/test_database_operations.py::test_execute_query_with_return PASSED [ 44%]
tests/infrastructure/persistence/test_database_operations.py::test_execute_many PASSED [ 44%]
tests/infrastructure/persistence/test_database_operations.py::test_get_last_row_id PASSED [ 45%]
tests/infrastructure/persistence/test_database_operations.py::test_close_connection PASSED [ 45%]
tests/infrastructure/persistence/test_database_operations.py::test_transaction_operations PASSED [ 45%]
tests/infrastructure/persistence/test_database_operations.py::test_create_engine_with_correct_url PASSED [ 45%]
tests/infrastructure/persistence/test_database_operations.py::test_session_creation PASSED [ 45%]
tests/infrastructure/persistence/test_database_operations.py::test_session_scope_provider_setup PASSED [ 45%]
tests/infrastructure/persistence/test_database_operations.py::test_init_db PASSED [ 45%]
tests/infrastructure/persistence/test_database_operations.py::test_ensure_all_models_mapped PASSED [ 46%]
tests/infrastructure/persistence/test_db_ops.py::test_simple PASSED      [ 46%]
tests/infrastructure/persistence/test_department_repository.py::test_add_department PASSED [ 46%]
tests/infrastructure/persistence/test_department_repository.py::test_add_department_duplicate_name PASSED [ 46%]
tests/infrastructure/persistence/test_department_repository.py::test_get_department_by_id PASSED [ 46%]
tests/infrastructure/persistence/test_department_repository.py::test_get_department_by_id_not_found PASSED [ 46%]
tests/infrastructure/persistence/test_department_repository.py::test_get_department_by_name PASSED [ 47%]
tests/infrastructure/persistence/test_department_repository.py::test_get_department_by_name_not_found PASSED [ 47%]
tests/infrastructure/persistence/test_department_repository.py::test_get_all_departments PASSED [ 47%]
tests/infrastructure/persistence/test_department_repository.py::test_update_department PASSED [ 47%]
tests/infrastructure/persistence/test_department_repository.py::test_delete_department PASSED [ 47%]
tests/infrastructure/persistence/test_department_repository.py::test_delete_department_with_linked_products_raises_error 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:repositories.py:165 - Unexpected error deleting department 6: Departamento 6 no puede ser eliminado, est√ü en uso por 1 productos.
PASSED                                                                   [ 47%]
tests/infrastructure/persistence/test_inventory_repository.py::test_add_movement PASSED [ 48%]
tests/infrastructure/persistence/test_inventory_repository.py::test_get_movements_for_product ERROR [ 48%]
tests/infrastructure/persistence/test_inventory_repository.py::test_get_all_movements ERROR [ 48%]
tests/infrastructure/persistence/test_invoice_repository.py::test_add_and_get_invoice PASSED [ 48%]
tests/infrastructure/persistence/test_invoice_repository.py::test_get_all_invoices PASSED [ 48%]
tests/infrastructure/persistence/test_invoice_repository.py::test_duplicate_sale_id_raises_error 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:23 [   ERROR] root:repositories.py:1071 - Error adding invoice: Invoice for sale ID 2 already exists
PASSED                                                                   [ 48%]
tests/infrastructure/persistence/test_product_repository.py::test_add_product PASSED [ 49%]
tests/infrastructure/persistence/test_product_repository.py::test_add_product_duplicate_code PASSED [ 49%]
tests/infrastructure/persistence/test_product_repository.py::test_get_product_by_id PASSED [ 49%]
tests/infrastructure/persistence/test_product_repository.py::test_get_product_by_id_not_found PASSED [ 49%]
tests/infrastructure/persistence/test_product_repository.py::test_get_product_by_code PASSED [ 49%]
tests/infrastructure/persistence/test_product_repository.py::test_get_product_by_code_not_found PASSED [ 49%]
tests/infrastructure/persistence/test_product_repository.py::test_get_all_products FAILED [ 50%]
tests/infrastructure/persistence/test_product_repository.py::test_update_product PASSED [ 50%]
tests/infrastructure/persistence/test_product_repository.py::test_delete_product ERROR [ 50%]
tests/infrastructure/persistence/test_product_repository.py::test_search_product ERROR [ 50%]
tests/infrastructure/persistence/test_product_repository.py::test_update_stock ERROR [ 50%]
tests/infrastructure/persistence/test_product_repository.py::test_get_low_stock ERROR [ 50%]
tests/infrastructure/persistence/test_product_repository.py::test_get_all_products_filtered_and_paginated ERROR [ 50%]
tests/infrastructure/persistence/test_product_repository.py::test_get_all_products_sorting ERROR [ 51%]
tests/infrastructure/persistence/test_repository_base.py::test_repository_initialization PASSED [ 51%]
tests/infrastructure/persistence/test_repository_base.py::test_session_property PASSED [ 51%]
tests/infrastructure/persistence/test_repository_base.py::test_session_property_no_session PASSED [ 51%]
tests/infrastructure/persistence/test_repository_base.py::test_set_session PASSED [ 51%]
tests/infrastructure/persistence/test_repository_base.py::test_entity_to_domain PASSED [ 51%]
tests/infrastructure/persistence/test_repository_base.py::test_domain_to_entity PASSED [ 52%]
tests/infrastructure/persistence/test_repository_base.py::test_get_by_id PASSED [ 52%]
tests/infrastructure/persistence/test_repository_base.py::test_get_all PASSED [ 52%]
tests/infrastructure/persistence/test_repository_base.py::test_add PASSED [ 52%]
tests/infrastructure/persistence/test_repository_base.py::test_update PASSED [ 52%]
tests/infrastructure/persistence/test_repository_base.py::test_delete PASSED [ 52%]
tests/infrastructure/persistence/test_sale_repository.py::test_add_sale PASSED [ 53%]
tests/infrastructure/persistence/test_sale_repository.py::test_get_sales_summary_by_period PASSED [ 53%]
tests/infrastructure/persistence/test_sale_repository.py::test_get_sales_by_payment_type FAILED [ 53%]
tests/infrastructure/persistence/test_sale_repository.py::test_get_sales_by_department PASSED [ 53%]
tests/infrastructure/persistence/test_sale_repository.py::test_get_sales_by_customer FAILED [ 53%]
tests/infrastructure/persistence/test_sale_repository.py::test_get_top_selling_products FAILED [ 53%]
tests/infrastructure/persistence/test_sale_repository.py::test_calculate_profit_for_period FAILED [ 54%]
tests/infrastructure/persistence/test_sale_repository.py::test_get_sale_by_id PASSED [ 54%]
tests/infrastructure/persistence/test_sale_repository.py::test_get_sales_by_period_filtering FAILED [ 54%]
tests/infrastructure/persistence/test_sale_repository_fixed.py::test_calculate_profit_for_period FAILED [ 54%]
tests/infrastructure/persistence/test_simple2.py::test_simple PASSED     [ 54%]
tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_initialization PASSED [ 54%]
tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_context_manager PASSED [ 54%]
tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_convenience_function PASSED [ 55%]
tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_shared_session PASSED [ 55%]
tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_transaction_commit 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:24 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: This Connection is closed
FAILED                                                                   [ 55%]
tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_transaction_rollback 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:25 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: This Connection is closed
FAILED                                                                   [ 55%]
tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_manual_commit 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:25 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: This Connection is closed
FAILED                                                                   [ 55%]
tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_manual_rollback 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:26 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: This Connection is closed
FAILED                                                                   [ 55%]
tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_complex_operation 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:26 [   ERROR] root:repositories.py:928 - Error adding customer: This Connection is closed
2025-07-18 14:54:26 [ WARNING] root:unit_of_work.py:109 - Exception in UnitOfWork, rolling back: This Connection is closed
FAILED                                                                   [ 56%]
tests/infrastructure/persistence/test_unit_of_work.py::test_unit_of_work_no_session_factory_error PASSED [ 56%]
tests/infrastructure/persistence/test_user_repository.py::TestUserRepository::test_add_user PASSED [ 56%]
tests/infrastructure/persistence/test_user_repository.py::TestUserRepository::test_add_user_duplicate_username 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:27 [   ERROR] root:repositories.py:1230 - Error adding user: Username 'duplicate_user_test2' already exists.
PASSED                                                                   [ 56%]
tests/infrastructure/persistence/test_user_repository.py::TestUserRepository::test_get_user_by_id PASSED [ 56%]
tests/infrastructure/persistence/test_user_repository.py::TestUserRepository::test_get_user_by_id_not_found PASSED [ 56%]
tests/infrastructure/persistence/test_user_repository.py::TestUserRepository::test_get_user_by_username PASSED [ 57%]
tests/infrastructure/persistence/test_user_repository.py::TestUserRepository::test_get_user_by_username_not_found PASSED [ 57%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_init_with_store_info PASSED [ 57%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_init_without_store_info PASSED [ 57%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_init_with_none_config_values PASSED [ 57%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_generate_invoice_creates_file PASSED [ 57%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_generate_receipt_creates_file PASSED [ 58%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_generate_presupuesto_creates_file PASSED [ 58%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_format_currency_receipt PASSED [ 58%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_format_sale_date_receipt PASSED [ 58%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_generate_invoice_handles_errors 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:27 [   ERROR] DocumentPdfGenerator:document_generator.py:181 - Error generating invoice PDF: PDF generation failed
PASSED                                                                   [ 58%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_invalid_output_path 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:27 [   ERROR] DocumentPdfGenerator:document_generator.py:118 - Cannot create directory for C:\invalid\path\with<invalid>chars\file.pdf: Invalid characters in path: C:\invalid\path\with<invalid>chars
2025-07-18 14:54:27 [   ERROR] DocumentPdfGenerator:document_generator.py:181 - Error generating invoice PDF: Invalid characters in path: C:\invalid\path\with<invalid>chars
PASSED                                                                   [ 58%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_empty_invoice_data 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:27 [   ERROR] DocumentPdfGenerator:document_generator.py:143 - Invoice data cannot be empty
PASSED                                                                   [ 58%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_missing_required_invoice_fields 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:27 [   ERROR] DocumentPdfGenerator:document_generator.py:150 - Missing required field: total
PASSED                                                                   [ 59%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_locale_handling PASSED [ 59%]
tests/infrastructure/reporting/test_document_generator.py::TestDocumentPdfGenerator::test_logger_initialization PASSED [ 59%]
tests/infrastructure/reporting/test_invoice_builder.py::TestInvoiceBuilder::test_error_handling PASSED [ 59%]
tests/infrastructure/reporting/test_invoice_builder.py::TestInvoiceBuilder::test_generate_invoice_pdf_custom_store_and_unusual_customer PASSED [ 59%]
tests/infrastructure/reporting/test_invoice_builder.py::TestInvoiceBuilder::test_generate_invoice_pdf_multi_page PASSED [ 59%]
tests/infrastructure/reporting/test_invoice_builder.py::TestInvoiceBuilder::test_generate_invoice_pdf_success PASSED [ 60%]
tests/infrastructure/reporting/test_invoice_builder.py::TestInvoiceBuilder::test_generate_invoice_pdf_type_a PASSED [ 60%]
tests/infrastructure/reporting/test_invoice_builder.py::TestInvoiceBuilder::test_generate_invoice_pdf_without_cae PASSED [ 60%]
tests/infrastructure/reporting/test_invoice_builder.py::TestInvoiceBuilder::test_invoice_pdf_content PASSED [ 60%]
tests/infrastructure/reporting/test_print_utility.py::TestPrintManager::test_init PASSED [ 60%]
tests/infrastructure/reporting/test_print_utility.py::TestPrintManager::test_get_store_info PASSED [ 60%]
tests/infrastructure/reporting/test_print_utility.py::TestPrintManager::test_generate_report PASSED [ 61%]
tests/infrastructure/reporting/test_print_utility.py::TestPrintManager::test_generate_receipt PASSED [ 61%]
tests/infrastructure/reporting/test_print_utility.py::TestPrintManager::test_generate_invoice PASSED [ 61%]
tests/infrastructure/reporting/test_print_utility.py::TestPrintManager::test_generate_cash_drawer_report PASSED [ 61%]
tests/infrastructure/reporting/test_print_utility.py::TestPrintManager::test_open_pdf 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:27 [ WARNING] root:print_utility.py:269 - _open_pdf received a relative path: test.pdf. This might lead to errors.
2025-07-18 14:54:27 [ WARNING] root:print_utility.py:269 - _open_pdf received a relative path: test.pdf. This might lead to errors.
2025-07-18 14:54:27 [ WARNING] root:print_utility.py:269 - _open_pdf received a relative path: test.pdf. This might lead to errors.
2025-07-18 14:54:27 [ WARNING] root:print_utility.py:269 - _open_pdf received a relative path: test.pdf. This might lead to errors.
PASSED                                                                   [ 61%]
tests/infrastructure/reporting/test_print_utility.py::TestPrintManager::test_print_to_printer PASSED [ 61%]
tests/infrastructure/reporting/test_print_utility.py::TestPrintManager::test_print_method 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:27 [   ERROR] root:print_utility.py:116 - Invalid print type: INVALID_TYPE
PASSED                                                                   [ 62%]
tests/infrastructure/reporting/test_print_utility.py::TestPrintManager::test_singleton_instance PASSED [ 62%]
tests/infrastructure/reporting/test_receipt_builder.py::TestReceiptBuilder::test_format_currency PASSED [ 62%]
tests/infrastructure/reporting/test_receipt_builder.py::TestReceiptBuilder::test_format_item_row PASSED [ 62%]
tests/infrastructure/reporting/test_receipt_builder.py::TestReceiptBuilder::test_format_sale_date PASSED [ 62%]
tests/infrastructure/reporting/test_receipt_builder.py::TestReceiptBuilder::test_generate_receipt_pdf PASSED [ 62%]
tests/infrastructure/test_alembic_migrations.py::test_alembic_upgrade_head_on_fresh_db PASSED [ 62%]
tests/infrastructure/test_alembic_migrations.py::test_product_and_department_tables_schema PASSED [ 63%]
tests/infrastructure/test_alembic_migrations.py::test_invoice_table_schema PASSED [ 63%]
tests/infrastructure/test_table_deps.py::test_direct_table_creation PASSED [ 63%]
tests/infrastructure/test_table_deps.py::test_table_order_validation PASSED [ 63%]
tests/integration/test_app_initialization.py::TestIntegrationWithoutLoginPrompt::test_invoicing_service_in_test_mode PASSED [ 63%]
tests/integration/test_db_simple.py::test_db_import PASSED               [ 63%]
tests/integration/test_db_simple.py::test_simple_db_session FAILED       [ 64%]
tests/integration/test_end_to_end_flows.py::TestSalesEndToEndFlow::test_complete_sale_process FAILED [ 64%]
tests/integration/test_end_to_end_flows.py::TestSalesEndToEndFlow::test_sale_with_error_handling FAILED [ 64%]
tests/integration/test_end_to_end_flows.py::TestInvoicingEndToEndFlow::test_invoice_generation_from_sale 
-------------------------------- live log call --------------------------------
2025-07-18 14:54:32 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with CUIT 20-12345678-9 already exists
FAILED                                                                   [ 64%]
tests/integration/test_end_to_end_flows.py::TestConcurrencyAndEdgeCases::test_inventory_updates_during_concurrent_sales PASSED [ 64%]
tests/integration/test_end_to_end_flows.py::TestConcurrencyAndEdgeCases::test_simple_product_creation FAILED [ 64%]
tests/integration/test_invoicing_integration.py::TestInvoicingIntegration::test_create_invoice_from_sale 
------------------------------- live log setup --------------------------------
2025-07-18 14:54:32 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with CUIT 20123456789 already exists
ERROR                                                                    [ 65%]
tests/integration/test_invoicing_integration.py::TestInvoicingIntegration::test_get_all_invoices 
------------------------------- live log setup --------------------------------
2025-07-18 14:54:32 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with CUIT 20123456789 already exists
ERROR                                                                    [ 65%]
tests/integration/test_invoicing_integration.py::TestInvoicingIntegration::test_generate_invoice_pdf 
------------------------------- live log setup --------------------------------
2025-07-18 14:54:32 [   ERROR] root:repositories.py:928 - Error adding customer: Customer with CUIT 20123456789 already exists
ERROR                                                                    [ 65%]
tests/integration/test_main_initialization.py::TestInvoicingServiceFixInMain::test_factory_approach PASSED [ 65%]
tests/integration/test_main_initialization.py::TestInvoicingServiceFixInMain::test_with_actual_repository PASSED [ 65%]
tests/integration/test_print_integration.py::test_cash_drawer_print_button PASSED [ 65%]
tests/integration/test_print_integration.py::test_cash_drawer_print_closed_drawer PASSED [ 66%]
tests/integration/test_print_integration.py::test_cash_drawer_print_error_handling PASSED [ 66%]
tests/integration/test_print_integration.py::test_corte_print_button PASSED [ 66%]
tests/integration/test_print_integration.py::test_corte_print_no_data PASSED [ 66%]
tests/integration/test_print_integration.py::test_corte_print_error_handling PASSED [ 66%]
tests/integration/test_products.py::test_product_model PASSED            [ 66%]
tests/integration/test_report_printing.py::test_report_view_print_button PASSED [ 66%]
tests/integration/test_report_printing.py::test_different_report_types_print_correctly PASSED [ 67%]
tests/integration/test_simple.py::test_simple PASSED                     [ 67%]
tests/integration/test_simple.py::test_import_exceptions PASSED          [ 67%]
tests/integration/test_simple.py::test_import_department PASSED          [ 67%]
tests/integration/test_user_integration.py::TestUserIntegration::test_add_user_valid_user_returns_user FAILED [ 67%]
tests/integration/test_user_integration.py::TestUserIntegration::test_add_user_duplicate_username_raises_value_error FAILED [ 67%]
tests/integration/test_user_integration.py::TestUserIntegration::test_authenticate_user_valid_credentials_returns_user FAILED [ 68%]
tests/integration/test_user_integration.py::TestUserIntegration::test_authenticate_user_invalid_credentials_returns_none FAILED [ 68%]
tests/minimal_test.py::test_minimal PASSED                               [ 68%]
tests/minimal_test.py::test_addition PASSED                              [ 68%]
tests/minimal_test.py::test_subtraction PASSED                           [ 68%]
tests/test_cash_drawer_dialogs_copy.py::TestOpenCashDrawerDialog::test_initialization PASSED [ 68%]
tests/test_cash_drawer_dialogs_copy.py::TestOpenCashDrawerDialog::test_accept_valid_amount PASSED [ 69%]
tests/test_cash_drawer_dialogs_copy.py::TestOpenCashDrawerDialog::test_accept_default_description PASSED [ 69%]
tests/test_cash_drawer_dialogs_copy.py::TestOpenCashDrawerDialog::test_service_error_on_accept PASSED [ 69%]
tests/test_cash_drawer_dialogs_copy.py::TestAddRemoveCashDialog::test_initialization_add PASSED [ 69%]
tests/test_cash_drawer_dialogs_copy.py::TestAddRemoveCashDialog::test_initialization_remove PASSED [ 69%]
tests/test_cash_drawer_dialogs_copy.py::TestAddRemoveCashDialog::test_accept_add_cash PASSED [ 69%]
tests/test_cash_drawer_dialogs_copy.py::TestAddRemoveCashDialog::test_accept_remove_cash PASSED [ 70%]
tests/test_cash_drawer_dialogs_copy.py::TestAddRemoveCashDialog::test_reject_missing_description PASSED [ 70%]
tests/test_cash_drawer_dialogs_copy.py::TestAddRemoveCashDialog::test_service_value_error_on_accept PASSED [ 70%]
tests/test_cash_drawer_dialogs_copy.py::TestCashDrawerHistoryDialog::test_apply_filter PASSED [ 70%]
tests/test_cash_drawer_dialogs_copy.py::TestCashDrawerHistoryDialog::test_service_error_on_filter PASSED [ 70%]
tests/test_cash_drawer_dialogs_copy.py::TestCashDrawerHistoryDialog::test_initialization_loads_today PASSED [ 70%]
tests/test_cash_drawer_dialogs_copy.py::TestCashDrawerHistoryDialog::test_summary_display_update PASSED [ 70%]
tests/test_qt_utils.py::test_wait_for_signal_timer PASSED                [ 71%]
tests/test_qt_utils.py::test_fake_network_access_manager PASSED          [ 71%]
tests/test_smoke.py::test_main_window_starts_and_shows PASSED            [ 71%]
tests/ui/dialogs/test_adjust_inventory_dialog.py::test_dialog_initialization PASSED [ 71%]
tests/ui/dialogs/test_adjust_inventory_dialog.py::test_update_result_label_increase PASSED [ 71%]
tests/ui/dialogs/test_adjust_inventory_dialog.py::test_update_result_label_decrease PASSED [ 71%]
tests/ui/dialogs/test_adjust_inventory_dialog.py::test_update_result_label_negative_stock PASSED [ 72%]
tests/ui/dialogs/test_adjust_inventory_dialog.py::test_accept_validation_quantity_zero PASSED [ 72%]
tests/ui/dialogs/test_adjust_inventory_dialog.py::test_accept_validation_no_reason PASSED [ 72%]
tests/ui/dialogs/test_adjust_inventory_dialog.py::test_accept_validation_negative_stock PASSED [ 72%]
tests/ui/dialogs/test_adjust_inventory_dialog.py::test_successful_increase_stock PASSED [ 72%]
tests/ui/dialogs/test_adjust_inventory_dialog.py::test_successful_decrease_stock PASSED [ 72%]
tests/ui/dialogs/test_adjust_inventory_dialog.py::test_service_error_handling PASSED [ 73%]
tests/ui/dialogs/test_customer_dialog.py::test_dialog_initialization_add_mode PASSED [ 73%]
tests/ui/dialogs/test_customer_dialog.py::test_dialog_initialization_edit_mode PASSED [ 73%]
tests/ui/dialogs/test_customer_dialog.py::test_validation_empty_name PASSED [ 73%]
tests/ui/dialogs/test_customer_dialog.py::test_validation_invalid_email PASSED [ 73%]
tests/ui/dialogs/test_customer_dialog.py::test_validation_empty_phone PASSED [ 73%]
tests/ui/dialogs/test_customer_dialog.py::test_validation_negative_credit_limit PASSED [ 74%]
tests/ui/dialogs/test_customer_dialog.py::test_successful_add_customer PASSED [ 74%]
tests/ui/dialogs/test_customer_dialog.py::test_successful_edit_customer PASSED [ 74%]
tests/ui/dialogs/test_customer_dialog.py::test_service_error_handling_add PASSED [ 74%]
tests/ui/dialogs/test_customer_dialog.py::test_service_error_handling_edit PASSED [ 74%]
tests/ui/dialogs/test_customer_dialog.py::test_cancel_dialog PASSED      [ 74%]
tests/ui/dialogs/test_customer_dialog.py::test_credit_limit_formatting PASSED [ 75%]
tests/ui/dialogs/test_customer_dialog.py::test_email_validation_accepts_valid_emails PASSED [ 75%]
tests/ui/dialogs/test_customer_dialog.py::test_phone_formatting PASSED   [ 75%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_init_simple_error PASSED [ 75%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_init_detailed_error PASSED [ 75%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_show_details_functionality PASSED [ 75%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_ok_button_closes_dialog PASSED [ 75%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_escape_key_closes_dialog PASSED [ 76%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_enter_key_closes_dialog PASSED [ 76%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_size_and_layout PASSED [ 76%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_with_empty_message PASSED [ 76%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_with_none_values PASSED [ 76%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_with_long_message PASSED [ 76%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_with_html_content PASSED [ 77%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_with_special_characters PASSED [ 77%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_modality PASSED [ 77%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_icon PASSED [ 77%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_focus_behavior PASSED [ 77%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_with_exception_object PASSED [ 77%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_accessibility PASSED [ 78%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_keyboard_navigation PASSED [ 78%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_resize_behavior PASSED [ 78%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_static_show_error_method PASSED [ 78%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_cleanup PASSED [ 78%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_with_various_inputs[Error 1-Message 1-None] PASSED [ 78%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_with_various_inputs[Error 2-Message 2-Details 2] PASSED [ 79%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_with_various_inputs[--] PASSED [ 79%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_with_various_inputs[Unicode: \u4e2d\u6587-Message: \xe1\xe9\xed\xf3\xfa-Details: \u20ac\xa3\xa5] PASSED [ 79%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_thread_safety PASSED [ 79%]
tests/ui/dialogs/test_error_dialog.py::TestErrorDialog::test_dialog_memory_usage PASSED [ 79%]
tests/ui/dialogs/test_login_dialog.py::test_dialog_initialization PASSED [ 79%]
tests/ui/dialogs/test_login_dialog.py::test_login_button_enabled_when_fields_filled PASSED [ 79%]
tests/ui/dialogs/test_login_dialog.py::test_successful_login PASSED      [ 80%]
tests/ui/dialogs/test_login_dialog.py::test_failed_login_invalid_credentials PASSED [ 80%]
tests/ui/dialogs/test_login_dialog.py::test_failed_login_inactive_user PASSED [ 80%]
tests/ui/dialogs/test_login_dialog.py::test_service_error_handling PASSED [ 80%]
tests/ui/dialogs/test_login_dialog.py::test_enter_key_triggers_login PASSED [ 80%]
tests/ui/dialogs/test_login_dialog.py::test_cancel_dialog PASSED         [ 80%]
tests/ui/dialogs/test_login_dialog.py::test_password_field_security PASSED [ 81%]
tests/ui/dialogs/test_login_dialog.py::test_username_case_insensitive PASSED [ 81%]
tests/ui/dialogs/test_login_dialog.py::test_multiple_failed_attempts PASSED [ 81%]
tests/ui/dialogs/test_login_dialog.py::test_remember_username_functionality PASSED [ 81%]
tests/ui/dialogs/test_login_dialog.py::test_show_hide_password_functionality PASSED [ 81%]
tests/ui/dialogs/test_product_dialog.py::test_dialog_initialization_add_mode PASSED [ 81%]
tests/ui/dialogs/test_product_dialog.py::test_dialog_initialization_edit_mode PASSED [ 82%]
tests/ui/dialogs/test_product_dialog.py::test_departments_loaded PASSED  [ 82%]
tests/ui/dialogs/test_product_dialog.py::test_service_validation_empty_code PASSED [ 82%]
tests/ui/dialogs/test_product_dialog.py::test_service_validation_empty_description PASSED [ 82%]
tests/ui/dialogs/test_product_dialog.py::test_service_validation_zero_cost_price PASSED [ 82%]
tests/ui/dialogs/test_product_dialog.py::test_service_validation_zero_sell_price PASSED [ 82%]
tests/ui/dialogs/test_product_dialog.py::test_successful_add_product PASSED [ 83%]
tests/ui/dialogs/test_product_dialog.py::test_successful_edit_product PASSED [ 83%]
tests/ui/dialogs/test_product_dialog.py::test_service_error_handling_add PASSED [ 83%]
tests/ui/dialogs/test_product_dialog.py::test_field_focus_on_validation_error PASSED [ 83%]
tests/ui/dialogs/test_product_dialog.py::test_duplicate_code_error_handling PASSED [ 83%]
tests/ui/dialogs/test_product_dialog.py::test_service_error_handling_edit PASSED [ 83%]
tests/ui/dialogs/test_product_dialog.py::test_cancel_dialog PASSED       [ 83%]
tests/ui/dialogs/test_product_dialog.py::test_uses_inventory_checkbox_behavior PASSED [ 84%]
tests/ui/dialogs/test_update_prices_dialog.py::test_dialog_creation_loads_departments PASSED [ 84%]
tests/ui/dialogs/test_update_prices_dialog.py::test_get_percentage_valid PASSED [ 84%]
tests/ui/dialogs/test_update_prices_dialog.py::test_get_percentage_invalid PASSED [ 84%]
tests/ui/dialogs/test_update_prices_dialog.py::test_accept_successful_update_all_departments PASSED [ 84%]
tests/ui/dialogs/test_update_prices_dialog.py::test_accept_successful_update_specific_department PASSED [ 84%]
tests/ui/dialogs/test_update_prices_dialog.py::test_accept_user_cancels_confirmation PASSED [ 85%]
tests/ui/dialogs/test_update_prices_dialog.py::test_accept_invalid_percentage_prevents_update PASSED [ 85%]
tests/ui/dialogs/test_update_prices_dialog.py::test_accept_service_raises_value_error PASSED [ 85%]
tests/ui/dialogs/test_update_prices_dialog.py::test_accept_service_raises_generic_exception PASSED [ 85%]
tests/ui/dialogs/test_update_prices_dialog.py::test_run_update_prices_dialog_accepted PASSED [ 85%]
tests/ui/dialogs/test_update_prices_dialog.py::test_run_update_prices_dialog_rejected PASSED [ 85%]
tests/ui/models/test_base_table_model.py::test_base_table_model_initialization PASSED [ 86%]
tests/ui/models/test_base_table_model.py::test_base_table_model_row_count PASSED [ 86%]
tests/ui/models/test_base_table_model.py::test_base_table_model_column_count PASSED [ 86%]
tests/ui/models/test_base_table_model.py::test_base_table_model_header_data_horizontal PASSED [ 86%]
tests/ui/models/test_base_table_model.py::test_base_table_model_header_data_out_of_bounds PASSED [ 86%]
tests/ui/models/test_base_table_model.py::test_base_table_model_header_data_vertical PASSED [ 86%]
tests/ui/models/test_base_table_model.py::test_base_table_model_header_data_other_role PASSED [ 87%]
tests/ui/models/test_base_table_model.py::test_base_table_model_update_data PASSED [ 87%]
tests/ui/models/test_base_table_model.py::test_base_table_model_get_item_at_row PASSED [ 87%]
tests/ui/models/test_base_table_model.py::test_base_table_model_get_item_at_row_out_of_bounds PASSED [ 87%]
tests/ui/models/test_base_table_model.py::test_concrete_table_model_data_method PASSED [ 87%]
tests/ui/styles/test_styles.py::test_colors_constants PASSED             [ 87%]
tests/ui/styles/test_styles.py::test_fonts_constants PASSED              [ 87%]
tests/ui/styles/test_styles.py::test_styles_templates PASSED             [ 88%]
tests/ui/styles/test_styles.py::test_apply_style_to_button PASSED        [ 88%]
tests/ui/styles/test_styles.py::test_apply_style_to_text_input PASSED    [ 88%]
tests/ui/styles/test_styles.py::test_apply_style_invalid_style PASSED    [ 88%]
tests/ui/styles/test_styles.py::test_style_integration_with_real_widgets PASSED [ 88%]
tests/ui/styles/test_styles.py::test_colors_in_style_templates PASSED    [ 88%]
tests/ui/test_filter_dropdowns.py::TestPeriodFilterWidget::test_widget_initialization PASSED [ 89%]
tests/ui/test_filter_dropdowns.py::TestPeriodFilterWidget::test_period_selection_today PASSED [ 89%]
tests/ui/test_filter_dropdowns.py::TestPeriodFilterWidget::test_period_selection_yesterday PASSED [ 89%]
tests/ui/test_filter_dropdowns.py::TestPeriodFilterWidget::test_period_selection_this_week PASSED [ 89%]
tests/ui/test_filter_dropdowns.py::TestPeriodFilterWidget::test_custom_period_selection PASSED [ 89%]
tests/ui/test_filter_dropdowns.py::TestPeriodFilterWidget::test_custom_date_application PASSED [ 89%]
tests/ui/test_filter_dropdowns.py::TestFilterDropdown::test_widget_initialization PASSED [ 90%]
tests/ui/test_filter_dropdowns.py::TestFilterDropdown::test_selection_change_signal PASSED [ 90%]
tests/ui/test_filter_dropdowns.py::TestFilterDropdown::test_get_selected_value PASSED [ 90%]
tests/ui/test_filter_dropdowns.py::TestFilterDropdown::test_get_selected_text PASSED [ 90%]
tests/ui/test_filter_dropdowns.py::TestFilterBoxWidget::test_widget_initialization PASSED [ 90%]
tests/ui/test_filter_dropdowns.py::TestFilterBoxWidget::test_add_widget PASSED [ 90%]
tests/ui/test_filter_dropdowns.py::TestFilterBoxWidget::test_add_separator PASSED [ 91%]
tests/ui/test_filter_dropdowns.py::TestFilterBoxWidget::test_add_stretch PASSED [ 91%]
tests/ui/test_keyboard_shortcuts.py::test_sales_view_shortcut_handling PASSED [ 91%]
tests/ui/test_minimal_widget.py::test_minimal_widget_instantiates PASSED [ 91%]
tests/ui/test_minimal_widget.py::test_button_click_updates_ui PASSED     [ 91%]
tests/ui/test_minimal_widget.py::test_service_interaction PASSED         [ 91%]
tests/ui/test_minimal_widget.py::test_widget_with_mocked_methods PASSED  [ 91%]
tests/ui/test_table_models.py::test_add_items_and_total PASSED           [ 92%]
tests/ui/test_table_models.py::test_add_duplicate_product_no_merge PASSED [ 92%]
tests/ui/test_table_models.py::test_customer_table_model_data_and_update PASSED [ 92%]
tests/ui/test_ui_noninteractive_components.py::test_base_table_model_basic PASSED [ 92%]
tests/ui/test_ui_noninteractive_components.py::test_product_table_model_display_and_alignment PASSED [ 92%]
tests/ui/test_ui_noninteractive_components.py::test_sale_item_table_model_operations PASSED [ 92%]
tests/ui/test_ui_noninteractive_components.py::test_report_table_model PASSED [ 93%]
tests/ui/test_ui_noninteractive_components.py::test_ui_utils_message_boxes PASSED [ 93%]
tests/ui/test_ui_noninteractive_components.py::test_ask_confirmation PASSED [ 93%]
tests/ui/test_ui_noninteractive_components.py::test_apply_standard_form_style PASSED [ 93%]
tests/ui/test_ui_noninteractive_components.py::test_customer_table_model_display_alignment_and_foreground PASSED [ 93%]
tests/ui/test_ui_noninteractive_components.py::test_cash_drawer_entry_table_model_display_and_alignment PASSED [ 93%]
tests/ui/views/test_sales_view.py::test_search_suggests_products PASSED  [ 94%]
tests/ui/views/test_sales_view.py::test_search_clears_suggestions_on_short_text PASSED [ 94%]
tests/ui/views/test_sales_view.py::test_search_no_results_populates_empty PASSED [ 94%]
tests/ui/views/test_sales_view.py::test_search_suggests_products_with_multiple_results PASSED [ 94%]
tests/ui/views/test_sales_view.py::test_search_suggests_products_with_no_results PASSED [ 94%]
tests/ui/views/test_sales_view.py::test_search_suggests_products_with_empty_text PASSED [ 94%]
tests/ui/views/test_sales_view.py::test_search_suggests_products_with_case_insensitive_search PASSED [ 95%]
tests/ui/views/test_sales_view.py::test_product_selected_from_combo_adds_to_sale PASSED [ 95%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_widget_initialization PASSED [ 95%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_custom_period_enables_dates PASSED [ 95%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_predefined_period_disables_dates PASSED [ 95%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_predefined[Hoy-0] PASSED [ 95%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_predefined[Ayer-1] PASSED [ 95%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_predefined[Esta semana-None] PASSED [ 96%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_predefined[Semana pasada-None] PASSED [ 96%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_predefined[Este mes-None] PASSED [ 96%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_predefined[Mes pasado-None] PASSED [ 96%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_predefined[Este a\xf1o-None] PASSED [ 96%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_predefined[A\xf1o pasado-None] PASSED [ 96%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_this_week PASSED [ 97%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_last_week PASSED [ 97%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_this_month PASSED [ 97%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_custom PASSED [ 97%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_get_date_range_custom_invalid_order PASSED [ 97%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_period_change_signal PASSED [ 97%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_change_signal PASSED [ 98%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_widget_has_filter_applied_signal PASSED [ 98%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_widgets_exist PASSED [ 98%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_signal_connections PASSED [ 98%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_fields_enabled_state[Hoy-False] PASSED [ 98%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_fields_enabled_state[Ayer-False] PASSED [ 98%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_fields_enabled_state[Esta semana-False] PASSED [ 99%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_fields_enabled_state[Semana pasada-False] PASSED [ 99%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_fields_enabled_state[Este mes-False] PASSED [ 99%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_fields_enabled_state[Mes pasado-False] PASSED [ 99%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_fields_enabled_state[Este a\xf1o-False] PASSED [ 99%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_fields_enabled_state[A\xf1o pasado-False] PASSED [ 99%]
tests/ui/widgets/test_filter_dropdowns.py::TestPeriodFilterWidget::test_date_fields_enabled_state[Personalizado-True] PASSED [100%]

=================================== ERRORS ====================================
______________ ERROR at setup of test_get_movements_for_product _______________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFBC11D0>

    @pytest.fixture
    def test_product_ids(test_db_session):
        """Create test products and return their IDs."""
        product_repo = SqliteProductRepository(test_db_session)
    
        # Add a product to associate movements with
        test_product = Product(
            code="TESTPROD",
            description="Test Product",
            cost_price=10.0,
            sell_price=20.0,
            uses_inventory=True
        )
        test_product_2 = Product(
            code="TESTPROD2",
            description="Test Product 2",
            cost_price=5.0,
            sell_price=15.0,
            uses_inventory=True
        )
>       added_product = product_repo.add(test_product)

tests\infrastructure\persistence\test_inventory_repository.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteProductRepository object at 0x0000021CDF8EA150>
product = Product(id=None, code='TESTPROD', description='Test Product', cost_price=Decimal('10.0'), sell_price=Decimal('20.0'), wholesale_price=None, special_price=None, department_id=None, department=None, unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('0.0'), min_stock=Decimal('0.0'), max_stock=None, uses_inventory=True, is_service=False)

    def add(self, product: Product) -> Product:
        """Adds a new product to the database."""
        # Check for existing code
        existing = self.get_by_code(product.code)
        if existing:
>           raise ValueError(f"Product code '{product.code}' already exists.")
E           ValueError: Product code 'TESTPROD' already exists.

infrastructure\persistence\sqlite\repositories.py:206: ValueError
__________________ ERROR at setup of test_get_all_movements ___________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDF9FF550>

    @pytest.fixture
    def test_product_ids(test_db_session):
        """Create test products and return their IDs."""
        product_repo = SqliteProductRepository(test_db_session)
    
        # Add a product to associate movements with
        test_product = Product(
            code="TESTPROD",
            description="Test Product",
            cost_price=10.0,
            sell_price=20.0,
            uses_inventory=True
        )
        test_product_2 = Product(
            code="TESTPROD2",
            description="Test Product 2",
            cost_price=5.0,
            sell_price=15.0,
            uses_inventory=True
        )
>       added_product = product_repo.add(test_product)

tests\infrastructure\persistence\test_inventory_repository.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteProductRepository object at 0x0000021CDF8A0BD0>
product = Product(id=None, code='TESTPROD', description='Test Product', cost_price=Decimal('10.0'), sell_price=Decimal('20.0'), wholesale_price=None, special_price=None, department_id=None, department=None, unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('0.0'), min_stock=Decimal('0.0'), max_stock=None, uses_inventory=True, is_service=False)

    def add(self, product: Product) -> Product:
        """Adds a new product to the database."""
        # Check for existing code
        existing = self.get_by_code(product.code)
        if existing:
>           raise ValueError(f"Product code '{product.code}' already exists.")
E           ValueError: Product code 'TESTPROD' already exists.

infrastructure\persistence\sqlite\repositories.py:206: ValueError
____________________ ERROR at setup of test_delete_product ____________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDF8CBB10>

    @pytest.fixture
    def setup_department(test_db_session):
        """Fixture to create and return a test department."""
>       dept = create_department(test_db_session)

tests\infrastructure\persistence\test_product_repository.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_product_repository.py:27: in create_department
    added_dept = dept_repo.add(dept)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteDepartmentRepository object at 0x0000021CDF9F9E50>
department = Department(id=None, name='Testing Dept', description=None)

    def add(self, department: Department) -> Department:
        """Adds a new department to the database."""
        # Check for existing name
        existing = self.get_by_name(department.name)
        if existing:
>           raise ValueError(f"Department name '{department.name}' already exists.")
E           ValueError: Department name 'Testing Dept' already exists.

infrastructure\persistence\sqlite\repositories.py:69: ValueError
____________________ ERROR at setup of test_search_product ____________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFDF7E50>

    @pytest.fixture
    def setup_department(test_db_session):
        """Fixture to create and return a test department."""
>       dept = create_department(test_db_session)

tests\infrastructure\persistence\test_product_repository.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_product_repository.py:27: in create_department
    added_dept = dept_repo.add(dept)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteDepartmentRepository object at 0x0000021CDFDCB490>
department = Department(id=None, name='Testing Dept', description=None)

    def add(self, department: Department) -> Department:
        """Adds a new department to the database."""
        # Check for existing name
        existing = self.get_by_name(department.name)
        if existing:
>           raise ValueError(f"Department name '{department.name}' already exists.")
E           ValueError: Department name 'Testing Dept' already exists.

infrastructure\persistence\sqlite\repositories.py:69: ValueError
_____________________ ERROR at setup of test_update_stock _____________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDE7BCC90>

    @pytest.fixture
    def setup_department(test_db_session):
        """Fixture to create and return a test department."""
>       dept = create_department(test_db_session)

tests\infrastructure\persistence\test_product_repository.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_product_repository.py:27: in create_department
    added_dept = dept_repo.add(dept)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteDepartmentRepository object at 0x0000021CDFB8FE50>
department = Department(id=None, name='Testing Dept', description=None)

    def add(self, department: Department) -> Department:
        """Adds a new department to the database."""
        # Check for existing name
        existing = self.get_by_name(department.name)
        if existing:
>           raise ValueError(f"Department name '{department.name}' already exists.")
E           ValueError: Department name 'Testing Dept' already exists.

infrastructure\persistence\sqlite\repositories.py:69: ValueError
____________________ ERROR at setup of test_get_low_stock _____________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDF8E9F90>

    @pytest.fixture
    def setup_department(test_db_session):
        """Fixture to create and return a test department."""
>       dept = create_department(test_db_session)

tests\infrastructure\persistence\test_product_repository.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_product_repository.py:27: in create_department
    added_dept = dept_repo.add(dept)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteDepartmentRepository object at 0x0000021CDFBE4210>
department = Department(id=None, name='Testing Dept', description=None)

    def add(self, department: Department) -> Department:
        """Adds a new department to the database."""
        # Check for existing name
        existing = self.get_by_name(department.name)
        if existing:
>           raise ValueError(f"Department name '{department.name}' already exists.")
E           ValueError: Department name 'Testing Dept' already exists.

infrastructure\persistence\sqlite\repositories.py:69: ValueError
_______ ERROR at setup of test_get_all_products_filtered_and_paginated ________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFBEDF50>

    @pytest.fixture
    def setup_department(test_db_session):
        """Fixture to create and return a test department."""
>       dept = create_department(test_db_session)

tests\infrastructure\persistence\test_product_repository.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_product_repository.py:27: in create_department
    added_dept = dept_repo.add(dept)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteDepartmentRepository object at 0x0000021CDFDFFA90>
department = Department(id=None, name='Testing Dept', description=None)

    def add(self, department: Department) -> Department:
        """Adds a new department to the database."""
        # Check for existing name
        existing = self.get_by_name(department.name)
        if existing:
>           raise ValueError(f"Department name '{department.name}' already exists.")
E           ValueError: Department name 'Testing Dept' already exists.

infrastructure\persistence\sqlite\repositories.py:69: ValueError
_______________ ERROR at setup of test_get_all_products_sorting _______________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFD85550>

    @pytest.fixture
    def setup_department(test_db_session):
        """Fixture to create and return a test department."""
>       dept = create_department(test_db_session)

tests\infrastructure\persistence\test_product_repository.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_product_repository.py:27: in create_department
    added_dept = dept_repo.add(dept)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteDepartmentRepository object at 0x0000021CDF8F8610>
department = Department(id=None, name='Testing Dept', description=None)

    def add(self, department: Department) -> Department:
        """Adds a new department to the database."""
        # Check for existing name
        existing = self.get_by_name(department.name)
        if existing:
>           raise ValueError(f"Department name '{department.name}' already exists.")
E           ValueError: Department name 'Testing Dept' already exists.

infrastructure\persistence\sqlite\repositories.py:69: ValueError
__ ERROR at setup of TestInvoicingIntegration.test_create_invoice_from_sale ___

self = <tests.integration.test_invoicing_integration.TestInvoicingIntegration object at 0x0000021CDF5D5650>
clean_db = (<sqlalchemy.orm.session.Session object at 0x0000021CE17B6850>, User(id=42, username='clean_db_testuser_95103244', email=None, password_hash='hash', password=None, is_active=True, is_admin=True))

    @pytest.fixture
    def customer(self, clean_db):
        """
        Create or retrieve a test customer.
    
        This fixture:
        - Checks if a customer with the test CUIT already exists in the session.
        - If exists, returns the existing customer.
        - If not, creates a new customer with valid test data, persists it, and returns it.
    
        Dependencies:
        - Requires clean_db fixture for a database session
        """
        # Correctly unpack the tuple yielded by clean_db
        session, _ = clean_db
        customer_repo = SqliteCustomerRepository(session)
        cuit_to_find = "20123456789"
    
        # Create a new one
        customer = Customer(
            name="Test Customer",
            address="123 Test St",
            cuit=cuit_to_find,
            iva_condition="Responsable Inscripto",
            email="test@example.com",
            phone="1234567890"
        )
>       customer = customer_repo.add(customer)

tests\integration\test_invoicing_integration.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CE108B050>
customer = Customer(name='Test Customer', id=UUID('f95be45f-59ef-4981-8265-29e98d3aa97b'), phone='1234567890', email='test@example.com', address='123 Test St', cuit='20123456789', iva_condition='Responsable Inscripto', credit_limit=0.0, credit_balance=0.0, is_active=True)

    def add(self, customer: Customer) -> Customer:
        """Add a new customer to the repository."""
        try:
            # Check for duplicate CUIT
            if customer.cuit:  # Only check if CUIT is provided
                existing_cuit = self.session.execute(
                    text("SELECT id FROM customers WHERE cuit = :cuit"),
                    {"cuit": customer.cuit}
                ).scalar_one_or_none()
    
                if existing_cuit:
>                   raise ValueError(f"Customer with CUIT {customer.cuit} already exists")
E                   ValueError: Customer with CUIT 20123456789 already exists

infrastructure\persistence\sqlite\repositories.py:878: ValueError
---------------------------- Captured stdout setup ----------------------------
Verifying mapping for 10 models...
Tables currently in Base.metadata: ['users', 'departments', 'products', 'inventory_movements', 'sales', 'sale_items', 'customers', 'credit_payments', 'invoices', 'cash_drawer_entries', 'test_items']
  - Model UserOrm correctly mapped to table 'users'
  - Model DepartmentOrm correctly mapped to table 'departments'
  - Model ProductOrm correctly mapped to table 'products'
  - Model InventoryMovementOrm correctly mapped to table 'inventory_movements'
  - Model SaleOrm correctly mapped to table 'sales'
  - Model SaleItemOrm correctly mapped to table 'sale_items'
  - Model CustomerOrm correctly mapped to table 'customers'
  - Model CreditPaymentOrm correctly mapped to table 'credit_payments'
  - Model InvoiceOrm correctly mapped to table 'invoices'
  - Model CashDrawerEntryOrm correctly mapped to table 'cash_drawer_entries'
Successfully verified 10 models mapped to 11 tables in Base.metadata.
All models mapped for TestInvoicingIntegration tests
----------------------------- Captured log setup ------------------------------
ERROR    root:repositories.py:928 Error adding customer: Customer with CUIT 20123456789 already exists
______ ERROR at setup of TestInvoicingIntegration.test_get_all_invoices _______

self = <tests.integration.test_invoicing_integration.TestInvoicingIntegration object at 0x0000021CDF5D5DD0>
clean_db = (<sqlalchemy.orm.session.Session object at 0x0000021CDFCC9990>, User(id=42, username='clean_db_testuser_e60cc059', email=None, password_hash='hash', password=None, is_active=True, is_admin=True))

    @pytest.fixture
    def customer(self, clean_db):
        """
        Create or retrieve a test customer.
    
        This fixture:
        - Checks if a customer with the test CUIT already exists in the session.
        - If exists, returns the existing customer.
        - If not, creates a new customer with valid test data, persists it, and returns it.
    
        Dependencies:
        - Requires clean_db fixture for a database session
        """
        # Correctly unpack the tuple yielded by clean_db
        session, _ = clean_db
        customer_repo = SqliteCustomerRepository(session)
        cuit_to_find = "20123456789"
    
        # Create a new one
        customer = Customer(
            name="Test Customer",
            address="123 Test St",
            cuit=cuit_to_find,
            iva_condition="Responsable Inscripto",
            email="test@example.com",
            phone="1234567890"
        )
>       customer = customer_repo.add(customer)

tests\integration\test_invoicing_integration.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CE1359CD0>
customer = Customer(name='Test Customer', id=UUID('fdf4f77c-b097-4400-9257-9f57cf6d9587'), phone='1234567890', email='test@example.com', address='123 Test St', cuit='20123456789', iva_condition='Responsable Inscripto', credit_limit=0.0, credit_balance=0.0, is_active=True)

    def add(self, customer: Customer) -> Customer:
        """Add a new customer to the repository."""
        try:
            # Check for duplicate CUIT
            if customer.cuit:  # Only check if CUIT is provided
                existing_cuit = self.session.execute(
                    text("SELECT id FROM customers WHERE cuit = :cuit"),
                    {"cuit": customer.cuit}
                ).scalar_one_or_none()
    
                if existing_cuit:
>                   raise ValueError(f"Customer with CUIT {customer.cuit} already exists")
E                   ValueError: Customer with CUIT 20123456789 already exists

infrastructure\persistence\sqlite\repositories.py:878: ValueError
----------------------------- Captured log setup ------------------------------
ERROR    root:repositories.py:928 Error adding customer: Customer with CUIT 20123456789 already exists
____ ERROR at setup of TestInvoicingIntegration.test_generate_invoice_pdf _____

self = <tests.integration.test_invoicing_integration.TestInvoicingIntegration object at 0x0000021CDF5D6510>
clean_db = (<sqlalchemy.orm.session.Session object at 0x0000021CE11425D0>, User(id=42, username='clean_db_testuser_5d00d253', email=None, password_hash='hash', password=None, is_active=True, is_admin=True))

    @pytest.fixture
    def customer(self, clean_db):
        """
        Create or retrieve a test customer.
    
        This fixture:
        - Checks if a customer with the test CUIT already exists in the session.
        - If exists, returns the existing customer.
        - If not, creates a new customer with valid test data, persists it, and returns it.
    
        Dependencies:
        - Requires clean_db fixture for a database session
        """
        # Correctly unpack the tuple yielded by clean_db
        session, _ = clean_db
        customer_repo = SqliteCustomerRepository(session)
        cuit_to_find = "20123456789"
    
        # Create a new one
        customer = Customer(
            name="Test Customer",
            address="123 Test St",
            cuit=cuit_to_find,
            iva_condition="Responsable Inscripto",
            email="test@example.com",
            phone="1234567890"
        )
>       customer = customer_repo.add(customer)

tests\integration\test_invoicing_integration.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CE1143590>
customer = Customer(name='Test Customer', id=UUID('7a2deb38-8b0d-4899-a88d-1463fa983b1b'), phone='1234567890', email='test@example.com', address='123 Test St', cuit='20123456789', iva_condition='Responsable Inscripto', credit_limit=0.0, credit_balance=0.0, is_active=True)

    def add(self, customer: Customer) -> Customer:
        """Add a new customer to the repository."""
        try:
            # Check for duplicate CUIT
            if customer.cuit:  # Only check if CUIT is provided
                existing_cuit = self.session.execute(
                    text("SELECT id FROM customers WHERE cuit = :cuit"),
                    {"cuit": customer.cuit}
                ).scalar_one_or_none()
    
                if existing_cuit:
>                   raise ValueError(f"Customer with CUIT {customer.cuit} already exists")
E                   ValueError: Customer with CUIT 20123456789 already exists

infrastructure\persistence\sqlite\repositories.py:878: ValueError
----------------------------- Captured log setup ------------------------------
ERROR    root:repositories.py:928 Error adding customer: Customer with CUIT 20123456789 already exists
================================== FAILURES ===================================
________ TestSQLiteCashDrawerRepository.test_get_last_start_entry_none ________

self = <test_cash_drawer_repository.TestSQLiteCashDrawerRepository object at 0x0000021CDE928350>
test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFB87A90>

    def test_get_last_start_entry_none(self, test_db_session):
        self.setup_for_test(test_db_session)
        repo = SQLiteCashDrawerRepository(test_db_session)
        # Add only non-start entries
        repo.add_entry(self.create_entry(CashDrawerEntryType.SALE, "50"))
        repo.add_entry(self.create_entry(CashDrawerEntryType.OUT, "10"))
    
        last_start = repo.get_last_start_entry()
>       assert last_start is None
E       AssertionError: assert CashDrawerEntry(id=3, timestamp=datetime.datetime(2025, 7, 18, 14, 54, 22, 902710), entry_type=<CashDrawerEntryType.START: 'START'>, amount=Decimal('100.00'), description='Test entry', user_id=1, drawer_id=1) is None

tests\infrastructure\persistence\test_cash_drawer_repository.py:177: AssertionError
___________________________ test_get_customer_by_id ___________________________

repository = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDFBDB290>
test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFDCBD10>

    def test_get_customer_by_id(repository, test_db_session):
        """Test retrieving a customer by ID."""
>       added_customer = _add_sample_customer(test_db_session)

tests\infrastructure\persistence\test_customer_repository.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_customer_repository.py:18: in _add_sample_customer
    return customer_repo.add(customer)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDFBD8C50>
customer = Customer(name='Test Customer', id=UUID('80b150cb-d8ac-47ac-b7cd-941417b714f5'), phone=None, email='test.customer@test.com', address=None, cuit='12345678', iva_condition=None, credit_limit=0.0, credit_balance=0.0, is_active=True)

    def add(self, customer: Customer) -> Customer:
        """Add a new customer to the repository."""
        try:
            # Check for duplicate CUIT
            if customer.cuit:  # Only check if CUIT is provided
                existing_cuit = self.session.execute(
                    text("SELECT id FROM customers WHERE cuit = :cuit"),
                    {"cuit": customer.cuit}
                ).scalar_one_or_none()
    
                if existing_cuit:
                    raise ValueError(f"Customer with CUIT {customer.cuit} already exists")
    
            # Check for duplicate email
            if customer.email: # Only check if email is provided
                existing_email = self.session.execute(
                    text("SELECT id FROM customers WHERE email = :email"),
                    {"email": customer.email}
                ).scalar_one_or_none()
    
                if existing_email:
>                   raise ValueError(f"Customer with email {customer.email} already exists")
E                   ValueError: Customer with email test.customer@test.com already exists

infrastructure\persistence\sqlite\repositories.py:888: ValueError
------------------------------ Captured log call ------------------------------
ERROR    root:repositories.py:928 Error adding customer: Customer with email test.customer@test.com already exists
__________________________ test_get_customer_by_cuit __________________________

repository = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDFCC6AD0>
test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFD69390>

    def test_get_customer_by_cuit(repository, test_db_session):
        """Test retrieving a customer by CUIT."""
        cuit = "55667788"
>       added_customer = _add_sample_customer(test_db_session, cuit=cuit)

tests\infrastructure\persistence\test_customer_repository.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_customer_repository.py:18: in _add_sample_customer
    return customer_repo.add(customer)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDFD09990>
customer = Customer(name='Test Customer', id=UUID('185c1cf0-a2bd-4daa-97f3-62e06449f377'), phone=None, email='test.customer@test.com', address=None, cuit='55667788', iva_condition=None, credit_limit=0.0, credit_balance=0.0, is_active=True)

    def add(self, customer: Customer) -> Customer:
        """Add a new customer to the repository."""
        try:
            # Check for duplicate CUIT
            if customer.cuit:  # Only check if CUIT is provided
                existing_cuit = self.session.execute(
                    text("SELECT id FROM customers WHERE cuit = :cuit"),
                    {"cuit": customer.cuit}
                ).scalar_one_or_none()
    
                if existing_cuit:
                    raise ValueError(f"Customer with CUIT {customer.cuit} already exists")
    
            # Check for duplicate email
            if customer.email: # Only check if email is provided
                existing_email = self.session.execute(
                    text("SELECT id FROM customers WHERE email = :email"),
                    {"email": customer.email}
                ).scalar_one_or_none()
    
                if existing_email:
>                   raise ValueError(f"Customer with email {customer.email} already exists")
E                   ValueError: Customer with email test.customer@test.com already exists

infrastructure\persistence\sqlite\repositories.py:888: ValueError
------------------------------ Captured log call ------------------------------
ERROR    root:repositories.py:928 Error adding customer: Customer with email test.customer@test.com already exists
___________________________ test_get_all_customers ____________________________

repository = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDFDB9390>
test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFDF7290>

    def test_get_all_customers(repository, test_db_session):
        """Test retrieving all customers."""
        _add_sample_customer(test_db_session, name="Customer Alpha", cuit="1")
        _add_sample_customer(test_db_session, name="Customer Beta", cuit="2")
        _add_sample_customer(test_db_session, name="Customer Gamma", cuit="3")
        test_db_session.commit()
    
        all_customers = repository.get_all()
>       assert len(all_customers) == 3
E       AssertionError: assert 7 == 3
E        +  where 7 = len([Customer(name='Customer Alpha', id=UUID('bfd85df2-1a21-43b5-b812-67f02f59479f'), phone=None, email='customer.alpha@test.com', address=None, cuit='1', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer Beta', id=UUID('87a464cd-341d-4ae3-b9ba-9804e416446b'), phone=None, email='customer.beta@test.com', address=None, cuit='2', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer Gamma', id=UUID('7ede1315-70e9-4a7c-8ecc-f26568ea8c2b'), phone=None, email='customer.gamma@test.com', address=None, cuit='3', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='First User', id=UUID('7c33e852-fa4e-425c-8eef-0a90580043e5'), phone=None, email='unique.email@example.com', address=None, cuit='10101010', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Test Customer', id=UUID('9744baa8-02f4-4a69-af1d-1cb51052aa4f'), phone='555-1234', email='test@example.com', address='123 Test St', cuit='20-12345678-9', iva_condition='Responsable Inscripto', credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Test Customer', id=UUID('8d0fe505-1ba2-4037-a72c-fb4f974a9330'), phone='555-1234', email='test1752843263@example.com', address='123 Test St', cuit='201752843263', iva_condition='Responsable Inscripto', credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Test Customer', id=UUID('6860cd86-31a7-499b-8165-a0c7ab50f4a6'), phone=None, email='test.customer@test.com', address=None, cuit='99887766', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True)])

tests\infrastructure\persistence\test_customer_repository.py:107: AssertionError
____________________________ test_update_customer _____________________________

repository = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDFDC8A50>
test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFDBAAD0>

    def test_update_customer(repository, test_db_session):
        """Test updating an existing customer."""
>       added_customer = _add_sample_customer(test_db_session)

tests\infrastructure\persistence\test_customer_repository.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_customer_repository.py:18: in _add_sample_customer
    return customer_repo.add(customer)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDFDC8790>
customer = Customer(name='Test Customer', id=UUID('28d009a7-4ac2-48f7-a282-82eeb55a6246'), phone=None, email='test.customer@test.com', address=None, cuit='12345678', iva_condition=None, credit_limit=0.0, credit_balance=0.0, is_active=True)

    def add(self, customer: Customer) -> Customer:
        """Add a new customer to the repository."""
        try:
            # Check for duplicate CUIT
            if customer.cuit:  # Only check if CUIT is provided
                existing_cuit = self.session.execute(
                    text("SELECT id FROM customers WHERE cuit = :cuit"),
                    {"cuit": customer.cuit}
                ).scalar_one_or_none()
    
                if existing_cuit:
                    raise ValueError(f"Customer with CUIT {customer.cuit} already exists")
    
            # Check for duplicate email
            if customer.email: # Only check if email is provided
                existing_email = self.session.execute(
                    text("SELECT id FROM customers WHERE email = :email"),
                    {"email": customer.email}
                ).scalar_one_or_none()
    
                if existing_email:
>                   raise ValueError(f"Customer with email {customer.email} already exists")
E                   ValueError: Customer with email test.customer@test.com already exists

infrastructure\persistence\sqlite\repositories.py:888: ValueError
------------------------------ Captured log call ------------------------------
ERROR    root:repositories.py:928 Error adding customer: Customer with email test.customer@test.com already exists
____________________________ test_delete_customer _____________________________

repository = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDFD8D4D0>
test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFD8C5D0>

    def test_delete_customer(repository, test_db_session):
        """Test deleting a customer."""
>       added_customer = _add_sample_customer(test_db_session)

tests\infrastructure\persistence\test_customer_repository.py:161: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_customer_repository.py:18: in _add_sample_customer
    return customer_repo.add(customer)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDFD8CD10>
customer = Customer(name='Test Customer', id=UUID('f9e83294-2523-432d-8faa-e57c28599467'), phone=None, email='test.customer@test.com', address=None, cuit='12345678', iva_condition=None, credit_limit=0.0, credit_balance=0.0, is_active=True)

    def add(self, customer: Customer) -> Customer:
        """Add a new customer to the repository."""
        try:
            # Check for duplicate CUIT
            if customer.cuit:  # Only check if CUIT is provided
                existing_cuit = self.session.execute(
                    text("SELECT id FROM customers WHERE cuit = :cuit"),
                    {"cuit": customer.cuit}
                ).scalar_one_or_none()
    
                if existing_cuit:
                    raise ValueError(f"Customer with CUIT {customer.cuit} already exists")
    
            # Check for duplicate email
            if customer.email: # Only check if email is provided
                existing_email = self.session.execute(
                    text("SELECT id FROM customers WHERE email = :email"),
                    {"email": customer.email}
                ).scalar_one_or_none()
    
                if existing_email:
>                   raise ValueError(f"Customer with email {customer.email} already exists")
E                   ValueError: Customer with email test.customer@test.com already exists

infrastructure\persistence\sqlite\repositories.py:888: ValueError
------------------------------ Captured log call ------------------------------
ERROR    root:repositories.py:928 Error adding customer: Customer with email test.customer@test.com already exists
______________________ test_get_all_customers_pagination ______________________

repository = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDFCF6610>
test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFB7FAD0>

    def test_get_all_customers_pagination(repository, test_db_session):
        """Test retrieving customers with pagination."""
        # Add 25 customers
        for i in range(25):
            _add_sample_customer(test_db_session, name=f"Customer {i}", cuit=str(i+1000))
        test_db_session.commit()
    
        # Test first page (10 results by default)
        # Use offset and limit instead of page and page_size
        page1 = repository.get_all(limit=10, offset=0)
        assert len(page1) == 10
    
        # Test second page
        page2 = repository.get_all(limit=10, offset=10)
        assert len(page2) == 10
    
        # Test third page (only 5 remaining)
        page3 = repository.get_all(limit=10, offset=20)
>       assert len(page3) == 5
E       AssertionError: assert 10 == 5
E        +  where 10 = len([Customer(name='Customer 4', id=UUID('12a6f7c6-e56f-4985-b0b1-143bde39fe87'), phone=None, email='customer.4@test.com', address=None, cuit='1004', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer 5', id=UUID('da1d047c-6fc9-4a59-a17e-cf9c81e03826'), phone=None, email='customer.5@test.com', address=None, cuit='1005', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer 6', id=UUID('4402dccd-bd06-4821-86d9-71e5ef920876'), phone=None, email='customer.6@test.com', address=None, cuit='1006', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer 7', id=UUID('531da55a-8667-49ca-ae5d-9f951559c078'), phone=None, email='customer.7@test.com', address=None, cuit='1007', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer 8', id=UUID('8fdee18d-aa2a-4bd9-a0d9-bd2cde3dd496'), phone=None, email='customer.8@test.com', address=None, cuit='1008', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer 9', id=UUID('5b918b1c-cd10-4d27-af45-ecec7de3339c'), phone=None, email='customer.9@test.com', address=None, cuit='1009', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer Alpha', id=UUID('bfd85df2-1a21-43b5-b812-67f02f59479f'), phone=None, email='customer.alpha@test.com', address=None, cuit='1', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer Beta', id=UUID('87a464cd-341d-4ae3-b9ba-9804e416446b'), phone=None, email='customer.beta@test.com', address=None, cuit='2', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer Gamma', id=UUID('7ede1315-70e9-4a7c-8ecc-f26568ea8c2b'), phone=None, email='customer.gamma@test.com', address=None, cuit='3', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='First User', id=UUID('7c33e852-fa4e-425c-8eef-0a90580043e5'), phone=None, email='unique.email@example.com', address=None, cuit='10101010', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True)])

tests\infrastructure\persistence\test_customer_repository.py:216: AssertionError
_________________ test_search_customers_filtering_and_sorting _________________

repository = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDF8CB0D0>
test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFB92110>

    def test_search_customers_filtering_and_sorting(repository, test_db_session):
        """Test advanced filtering and sorting of customers."""
        # Add test customers with varied attributes
>       _add_sample_customer(
            test_db_session,
            name="Gold Customer",
            cuit="1001",
            credit_limit=10000.0,
            iva_condition="Responsable Inscripto"
        )

tests\infrastructure\persistence\test_customer_repository.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\infrastructure\persistence\test_customer_repository.py:18: in _add_sample_customer
    return customer_repo.add(customer)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDF8CB350>
customer = Customer(name='Gold Customer', id=UUID('821f9b51-722c-4092-b485-19040d0bbe62'), phone=None, email='gold.customer@test.com', address=None, cuit='1001', iva_condition='Responsable Inscripto', credit_limit=10000.0, credit_balance=0.0, is_active=True)

    def add(self, customer: Customer) -> Customer:
        """Add a new customer to the repository."""
        try:
            # Check for duplicate CUIT
            if customer.cuit:  # Only check if CUIT is provided
                existing_cuit = self.session.execute(
                    text("SELECT id FROM customers WHERE cuit = :cuit"),
                    {"cuit": customer.cuit}
                ).scalar_one_or_none()
    
                if existing_cuit:
>                   raise ValueError(f"Customer with CUIT {customer.cuit} already exists")
E                   ValueError: Customer with CUIT 1001 already exists

infrastructure\persistence\sqlite\repositories.py:878: ValueError
------------------------------ Captured log call ------------------------------
ERROR    root:repositories.py:928 Error adding customer: Customer with CUIT 1001 already exists
____________________________ test_get_all_products ____________________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFC4A990>
setup_department = Department(id=7, name='Testing Dept', description=None)
request = <FixtureRequest for <Function test_get_all_products>>

    def test_get_all_products(test_db_session, setup_department, request):
        """Test retrieving all products with transactional isolation."""
    
        # Test setup
        dept = setup_department
        repo = SqliteProductRepository(test_db_session)
    
        # Add products and commit
        prod1 = repo.add(Product(code="ALL01", description="All Prod 1", department_id=dept.id))
        prod2 = repo.add(Product(code="ALL02", description="All Prod 2", department_id=dept.id))
    
        all_prods = repo.get_all()
>       assert len(all_prods) == 2
E       AssertionError: assert 5 == 2
E        +  where 5 = len([Product(id=4, code='ALL01', description='All Prod 1', cost_price=Decimal('0.00'), sell_price=Decimal('0.00'), wholesale_price=None, special_price=None, department_id=7, department=Department(id=7, name='Testing Dept', description=None), unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('0.000'), min_stock=Decimal('0.000'), max_stock=None, uses_inventory=True, is_service=False), Product(id=5, code='ALL02', description='All Prod 2', cost_price=Decimal('0.00'), sell_price=Decimal('0.00'), wholesale_price=None, special_price=None, department_id=7, department=Department(id=7, name='Testing Dept', description=None), unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('0.000'), min_stock=Decimal('0.000'), max_stock=None, uses_inventory=True, is_service=False), Product(id=1, code='P001', description='Test Product', cost_price=Decimal('50.00'), sell_price=Decimal('100.00'), wholesale_price=None, special_price=None, department_id=None, department=None, unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('10.000'), min_stock=Decimal('1.000'), max_stock=None, uses_inventory=True, is_service=False), Product(id=2, code='TESTPROD', description='Test Product', cost_price=Decimal('10.00'), sell_price=Decimal('20.00'), wholesale_price=None, special_price=None, department_id=None, department=None, unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('0.000'), min_stock=Decimal('0.000'), max_stock=None, uses_inventory=True, is_service=False), Product(id=3, code='TESTPROD2', description='Test Product 2', cost_price=Decimal('5.00'), sell_price=Decimal('15.00'), wholesale_price=None, special_price=None, department_id=None, department=None, unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('0.000'), min_stock=Decimal('0.000'), max_stock=None, uses_inventory=True, is_service=False)])

tests\infrastructure\persistence\test_product_repository.py:135: AssertionError
_______________________ test_get_sales_by_payment_type ________________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CE102C890>
create_product = <function create_product.<locals>._create_product at 0x0000021CE1075120>
create_customer = <function create_customer.<locals>._create_customer at 0x0000021CE1074180>

    def test_get_sales_by_payment_type(test_db_session, create_product, create_customer):
        """Test getting sales summarized by payment type."""
        # Create test data
        product = create_product("PAYTEST", "Payment Test Product", 10.0, 5.0)
        customer = create_customer()
        test_db_session.commit()
    
        repository = SqliteSaleRepository(test_db_session)
    
        # Create sales with different payment types
        now = datetime.now()
    
        # Cash sales (2)
        for _ in range(2):
            sale = Sale(timestamp=now, payment_type="CASH", customer_id=customer.id, user_id=1)
            sale.items = [
                SaleItem(product_id=product.id, quantity=Decimal('1'), unit_price=Decimal('10.0'),
                         product_code=product.code, product_description=product.description)
            ]
            repository.add_sale(sale)
    
        # Card sales (3)
        for _ in range(3):
            sale = Sale(timestamp=now, payment_type="CARD", customer_id=customer.id, user_id=1)
            sale.items = [
                SaleItem(product_id=product.id, quantity=Decimal('1'), unit_price=Decimal('10.0'),
                         product_code=product.code, product_description=product.description)
            ]
            repository.add_sale(sale)
    
        test_db_session.commit()
    
        # Test get_sales_by_payment_type
        payment_summary = repository.get_sales_by_payment_type()
    
        # Should have 2 payment types
>       assert len(payment_summary) == 2
E       AssertionError: assert 3 == 2
E        +  where 3 = len([{'payment_type': 'cash', 'total_sales': 200.0, 'num_sales': 1}, {'payment_type': 'CARD', 'total_sales': 30.0, 'num_sales': 3}, {'payment_type': 'CASH', 'total_sales': 20.0, 'num_sales': 2}])

tests\infrastructure\persistence\test_sale_repository.py:254: AssertionError
_________________________ test_get_sales_by_customer __________________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CE104DE50>
create_product = <function create_product.<locals>._create_product at 0x0000021CE1077CE0>
create_customer = <function create_customer.<locals>._create_customer at 0x0000021CE100C4A0>

    def test_get_sales_by_customer(test_db_session, create_product, create_customer):
        """Test getting sales summarized by customer."""
        # Create test data
        product = create_product("CUSTTEST", "Customer Test Product", 10.0, 5.0)
    
        # Make sure to use uniqueness for each customer
        timestamp1 = int(time.time() * 1000)
        timestamp2 = timestamp1 + 100  # Use a larger offset to ensure unique timestamps
    
        customer1 = create_customer(f"Customer One {timestamp1}")
    
        # Force a small delay to ensure different timestamps for CUIT
        time.sleep(0.01)
        timestamp2 = int(time.time() * 1000)  # Get a fresh timestamp
    
        customer2 = create_customer(f"Customer Two {timestamp2}")
        test_db_session.commit()
    
        repository = SqliteSaleRepository(test_db_session)
    
        # Create sales for each customer
        now = datetime.now()
    
        # Sales for customer 1 (more sales/volume)
        sale1 = Sale(timestamp=now - timedelta(days=5), payment_type="CASH", customer_id=customer1.id, user_id=1)
        sale1.items = [
            SaleItem(product_id=product.id, quantity=Decimal('3'), unit_price=Decimal('10.0'),
                      product_code=product.code, product_description=product.description)
        ]
        repository.add_sale(sale1)
    
        sale2 = Sale(timestamp=now - timedelta(days=3), payment_type="CASH", customer_id=customer1.id, user_id=1)
        sale2.items = [
            SaleItem(product_id=product.id, quantity=Decimal('2'), unit_price=Decimal('10.0'),
                      product_code=product.code, product_description=product.description)
        ]
        repository.add_sale(sale2)
    
        # Sale for customer 2 (less volume)
        sale3 = Sale(timestamp=now - timedelta(days=2), payment_type="CARD", customer_id=customer2.id, user_id=1)
        sale3.items = [
            SaleItem(product_id=product.id, quantity=Decimal('1'), unit_price=Decimal('10.0'),
                      product_code=product.code, product_description=product.description)
        ]
        repository.add_sale(sale3)
    
        test_db_session.commit()
    
        # Get sales by customer
        summary = repository.get_sales_by_customer(now - timedelta(days=10), now, limit=5)
    
        # Should have 2 customers
>       assert len(summary) == 2
E       AssertionError: assert 3 == 2
E        +  where 3 = len([{'customer_id': UUID('9744baa8-02f4-4a69-af1d-1cb51052aa4f'), 'customer_name': 'Test Customer', 'total_sales': 200.0, 'num_sales': 1}, {'customer_id': UUID('45122714-3557-4627-9245-c4c99cb4287d'), 'customer_name': 'Customer One 1752843264639', 'total_sales': 50.0, 'num_sales': 2}, {'customer_id': UUID('51d542df-a546-49fb-b0b8-40a5e67f160c'), 'customer_name': 'Customer Two 1752843264653', 'total_sales': 10.0, 'num_sales': 1}])

tests\infrastructure\persistence\test_sale_repository.py:383: AssertionError
________________________ test_get_top_selling_products ________________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFD75110>
create_product = <function create_product.<locals>._create_product at 0x0000021CE100C540>
create_customer = <function create_customer.<locals>._create_customer at 0x0000021CE100C180>

    def test_get_top_selling_products(test_db_session, create_product, create_customer):
        """Test getting top selling products."""
        # Create test data
        product1 = create_product("TOP1", "Top Product 1", 10.0, 5.0)
        product2 = create_product("TOP2", "Top Product 2", 20.0, 10.0)
        product3 = create_product("TOP3", "Top Product 3", 30.0, 15.0)
        customer = create_customer()
        test_db_session.commit()
    
        repository = SqliteSaleRepository(test_db_session)
    
        # Create sales with different products
        # Product 1: 5 units
        sale1 = Sale(timestamp=datetime.now(), payment_type="CASH", customer_id=customer.id, user_id=1)
        sale1.items = [
            SaleItem(product_id=product1.id, quantity=Decimal('5'), unit_price=Decimal('10.0'),
                     product_code=product1.code, product_description=product1.description)
        ]
        repository.add_sale(sale1)
    
        # Product 2: 3 units
        sale2 = Sale(timestamp=datetime.now(), payment_type="CASH", customer_id=customer.id, user_id=1)
        sale2.items = [
            SaleItem(product_id=product2.id, quantity=Decimal('3'), unit_price=Decimal('20.0'),
                     product_code=product2.code, product_description=product2.description)
        ]
        repository.add_sale(sale2)
    
        # Product 3: 1 unit
        sale3 = Sale(timestamp=datetime.now(), payment_type="CASH", customer_id=customer.id, user_id=1)
        sale3.items = [
            SaleItem(product_id=product3.id, quantity=Decimal('1'), unit_price=Decimal('30.0'),
                     product_code=product3.code, product_description=product3.description)
        ]
        repository.add_sale(sale3)
    
        test_db_session.commit()
    
        # Test get_top_selling_products (quantity)
        top_products = repository.get_top_selling_products()
    
        # Should have 3 products, ordered by quantity sold
>       assert len(top_products) == 3
E       AssertionError: assert 4 == 3
E        +  where 4 = len([{'product_id': 13, 'product_code': 'TOP1_1752843264687', 'product_description': 'Top Product 1', 'quantity_sold': Decimal('5.000')}, {'product_id': 14, 'product_code': 'TOP2_1752843264689', 'product_description': 'Top Product 2', 'quantity_sold': Decimal('3.000')}, {'product_id': 1, 'product_code': 'P001', 'product_description': 'Test Product', 'quantity_sold': Decimal('2.000')}, {'product_id': 15, 'product_code': 'TOP3_1752843264693', 'product_description': 'Top Product 3', 'quantity_sold': Decimal('1.000')}])

tests\infrastructure\persistence\test_sale_repository.py:437: AssertionError
______________________ test_calculate_profit_for_period _______________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFCC5590>
create_product = <function create_product.<locals>._create_product at 0x0000021CE100DB20>
create_customer = <function create_customer.<locals>._create_customer at 0x0000021CE100D080>

    def test_calculate_profit_for_period(test_db_session, create_product, create_customer):
        """Test calculating profit for a period."""
        # Create test data
        product1 = create_product("PROFIT1", "Profit Product 1", price=10.0, cost=5.0)  # 50% margin
        product2 = create_product("PROFIT2", "Profit Product 2", price=20.0, cost=16.0)  # 20% margin
        customer = create_customer()
        test_db_session.commit()
    
        repository = SqliteSaleRepository(test_db_session)
    
        # Create sales for the current date (today)
        now = datetime.now()
    
        # First sale - should be included in period
        sale1 = Sale(timestamp=now, payment_type="CASH", customer_id=customer.id, user_id=1)
        sale1.items = [
            SaleItem(product_id=product1.id, quantity=Decimal('5'), unit_price=Decimal('10.0'),
                     product_code=product1.code, product_description=product1.description)
        ]
        repository.add_sale(sale1)
    
        # Second sale - should be included in period
        sale2 = Sale(timestamp=now, payment_type="CARD", customer_id=customer.id, user_id=1)
        sale2.items = [
            SaleItem(product_id=product2.id, quantity=Decimal('2'), unit_price=Decimal('20.0'),
                     product_code=product2.code, product_description=product2.description)
        ]
        repository.add_sale(sale2)
    
        test_db_session.commit()
    
        # Test calculate_profit_for_period for today only
        start_date = now.date()
        end_date = now.date()
    
        profit_data = repository.calculate_profit_for_period(start_date, end_date)
    
        # Total sales: (5 * $10) + (2 * $20) = $50 + $40 = $90
        # Total cost: (5 * $5) + (2 * $16) = $25 + $32 = $57
        # Profit: $90 - $57 = $33
    
>       assert profit_data['revenue'] == 90.0
E       assert 290.0 == 90.0

tests\infrastructure\persistence\test_sale_repository.py:491: AssertionError
_____________________ test_get_sales_by_period_filtering ______________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDFCC9890>
create_product = <function create_product.<locals>._create_product at 0x0000021CE100FA60>
create_customer = <function create_customer.<locals>._create_customer at 0x0000021CE100F1A0>

    def test_get_sales_by_period_filtering(test_db_session, create_product, create_customer):
        """Test filtering sales by period."""
        # Create test data
        product = create_product("PERIOD", "Period Test Product", 10.0, 5.0)
        customer = create_customer()
        test_db_session.commit()
    
        repository = SqliteSaleRepository(test_db_session)
    
        # Create sales for different dates
        now = datetime.now()
        yesterday = now - timedelta(days=1)
        two_days_ago = now - timedelta(days=2)
    
        # Day 1 sale
        sale1 = Sale(timestamp=two_days_ago, payment_type="CASH", customer_id=customer.id, user_id=1)
        sale1.items = [
            SaleItem(product_id=product.id, quantity=Decimal('1'), unit_price=Decimal('10.0'),
                     product_code=product.code, product_description=product.description)
        ]
        repository.add_sale(sale1)
    
        # Day 2 sale
        sale2 = Sale(timestamp=yesterday, payment_type="CARD", customer_id=customer.id, user_id=1)
        sale2.items = [
            SaleItem(product_id=product.id, quantity=Decimal('1'), unit_price=Decimal('10.0'),
                     product_code=product.code, product_description=product.description)
        ]
        repository.add_sale(sale2)
    
        # Day 3 (today) sale
        sale3 = Sale(timestamp=now, payment_type="CASH", customer_id=customer.id, user_id=1)
        sale3.items = [
            SaleItem(product_id=product.id, quantity=Decimal('1'), unit_price=Decimal('10.0'),
                     product_code=product.code, product_description=product.description)
        ]
        repository.add_sale(sale3)
    
        test_db_session.commit()
    
        # Test get_sales_by_period with different date ranges
    
        # Full range (all sales)
        start_full = two_days_ago - timedelta(hours=1)
        end_full = now + timedelta(hours=1)
        sales_full = repository.get_sales_by_period(start_full, end_full)
>       assert len(sales_full) == 3
E       AssertionError: assert 4 == 3
E        +  where 4 = len([Sale(id=4, timestamp=datetime.datetime(2025, 7, 18, 14, 54, 24, 782639), items=[SaleItem(product_id=19, quantity=Decimal('1.000'), unit_price=Decimal('10.00'), id=4, sale_id=4, product_code='PERIOD_1752843264780', product_description='Period Test Product')], customer_id=UUID('b5163b78-97d9-4a5a-81e9-533d65b2a038'), is_credit_sale=False, user_id=1, payment_type='CASH'), Sale(id=1, timestamp=datetime.datetime(2025, 7, 18, 14, 54, 21, 108824), items=[SaleItem(product_id=1, quantity=Decimal('2.000'), unit_price=Decimal('100.00'), id=1, sale_id=1, product_code='P001', product_description='Test Product')], customer_id=UUID('9744baa8-02f4-4a69-af1d-1cb51052aa4f'), is_credit_sale=False, user_id=None, payment_type='cash'), Sale(id=3, timestamp=datetime.datetime(2025, 7, 17, 14, 54, 24, 782639), items=[SaleItem(product_id=19, quantity=Decimal('1.000'), unit_price=Decimal('10.00'), id=3, sale_id=3, product_code='PERIOD_1752843264780', product_description='Period Test Product')], customer_id=UUID('b5163b78-97d9-4a5a-81e9-533d65b2a038'), is_credit_sale=False, user_id=1, payment_type='CARD'), Sale(id=2, timestamp=datetime.datetime(2025, 7, 16, 14, 54, 24, 782639), items=[SaleItem(product_id=19, quantity=Decimal('1.000'), unit_price=Decimal('10.00'), id=2, sale_id=2, product_code='PERIOD_1752843264780', product_description='Period Test Product')], customer_id=UUID('b5163b78-97d9-4a5a-81e9-533d65b2a038'), is_credit_sale=False, user_id=1, payment_type='CASH')])

tests\infrastructure\persistence\test_sale_repository.py:579: AssertionError
______________________ test_calculate_profit_for_period _______________________

test_db_session = <sqlalchemy.orm.session.Session object at 0x0000021CDF88C3D0>
create_product = <function create_product.<locals>._create_product at 0x0000021CE1038EA0>
create_customer = <function create_customer.<locals>._create_customer at 0x0000021CE1039C60>

    def test_calculate_profit_for_period(test_db_session, create_product, create_customer):
        """Test calculating profit for a period."""
        # Create test data
        product1 = create_product("PROFIT1", "Profit Product 1", price=10.0, cost=5.0)  # 50% margin
        product2 = create_product("PROFIT2", "Profit Product 2", price=20.0, cost=16.0)  # 20% margin
        customer = create_customer()
    
        repository = SqliteSaleRepository(test_db_session)
    
        # Create sales for different dates - same day
        now = datetime.now()
    
        # First sale
        sale1 = Sale(timestamp=now, payment_type="CASH", customer_id=customer.id, user_id=1)
        sale1.items = [
            SaleItem(product_id=product1.id, quantity=Decimal('5'), unit_price=Decimal('10.0'),
                     product_code=product1.code, product_description=product1.description)
        ]
        repository.add_sale(sale1)
    
        # Second sale
        sale2 = Sale(timestamp=now, payment_type="CARD", customer_id=customer.id, user_id=1)
        sale2.items = [
            SaleItem(product_id=product2.id, quantity=Decimal('2'), unit_price=Decimal('20.0'),
                     product_code=product2.code, product_description=product2.description)
        ]
        repository.add_sale(sale2)
    
        # Commit the changes to make sure they're visible
        test_db_session.commit()
    
        # Inspect the sales data to confirm
        sales_query = test_db_session.query(SaleOrm).all()
        print(f"Found {len(sales_query)} sales in the database")
    
        for sale in sales_query:
            print(f"Sale ID: {sale.id}, Time: {sale.date_time}, Items: {len(sale.items)}")
            for item in sale.items:
                print(f"  - Item ID: {item.id}, Product ID: {item.product_id}, Quantity: {item.quantity}, Price: {item.unit_price}")
    
        # Calculate expected values
        expected_revenue = 5 * 10.0 + 2 * 20.0  # 50 + 40 = 90
        expected_cost = 5 * 5.0 + 2 * 16.0      # 25 + 32 = 57
        expected_profit = expected_revenue - expected_cost
    
        # Test calculate_profit_for_period for today
        start_date = now.date()  # Today's date
        end_date = now.date()    # Today's date
    
        print(f"Calculating profit for period: {start_date} to {end_date}")
        profit_data = repository.calculate_profit_for_period(start_date, end_date)
        print(f"Result: {profit_data}")
    
        # In this test we expect specific values - both sales should be included
>       assert profit_data['revenue'] == expected_revenue
E       assert 290.0 == 90.0

tests\infrastructure\persistence\test_sale_repository_fixed.py:136: AssertionError
---------------------------- Captured stdout call -----------------------------
Found 3 sales in the database
Sale ID: 1, Time: 2025-07-18 14:54:21.108824, Items: 1
  - Item ID: 1, Product ID: 1, Quantity: 2.000, Price: 100.00
Sale ID: 2, Time: 2025-07-18 14:54:24.838592, Items: 1
  - Item ID: 2, Product ID: 20, Quantity: 5.000, Price: 10.00
Sale ID: 3, Time: 2025-07-18 14:54:24.838592, Items: 1
  - Item ID: 3, Product ID: 21, Quantity: 2.000, Price: 20.00
Calculating profit for period: 2025-07-18 to 2025-07-18
Result: {'revenue': 290.0, 'cost': 157.0, 'profit': 133.0, 'margin': 0.4586206896551724}
_____________ TestUnitOfWork.test_unit_of_work_transaction_commit _____________

self = <test_unit_of_work.TestUnitOfWork object at 0x0000021CDE9DBBD0>
clean_db = (<sqlalchemy.orm.session.Session object at 0x0000021CDF9F8110>, User(id=40, username='clean_db_testuser_625b30cb', email=None, password_hash='hash', password=None, is_active=True, is_admin=True))

    def test_unit_of_work_transaction_commit(self, clean_db):
        """Test that successful operations are committed."""
        session, domain_user = clean_db
    
        # Create a department and product in the same transaction
        with UnitOfWork() as uow:
            # Add department
            department = Department(name="Test Department UoW")
>           created_dept = uow.departments.add(department)

tests\infrastructure\persistence\test_unit_of_work.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
infrastructure\persistence\sqlite\repositories.py:67: in add
    existing = self.get_by_name(department.name)
infrastructure\persistence\sqlite\repositories.py:101: in get_by_name
    department_orm = self.session.scalars(stmt).first()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2473: in scalars
    return self._execute_internal(
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2241: in _execute_internal
    conn = self._connection_for_bind(bind)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2110: in _connection_for_bind
    return trans._connection_for_bind(engine, execution_options)
<string>:2: in _connection_for_bind
    ???
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:1242: in _connection_for_bind
    transaction = conn.begin()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:859: in begin
    self._transaction = RootTransaction(self)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2681: in __init__
    self._connection_begin_impl()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2699: in _connection_begin_impl
    self.connection._begin_impl(self)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:1107: in _begin_impl
    self._handle_dbapi_exception(e, None, None, None, None)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise exc_info[1].with_traceback(exc_info[2])
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:1105: in _begin_impl
    self.engine.dialect.do_begin(self.connection)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:584: in connection
    return self._revalidate_connection()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.engine.base.Connection object at 0x0000021CDF97E850>

    def _revalidate_connection(self) -> PoolProxiedConnection:
        if self.__can_reconnect and self.invalidated:
            if self._transaction is not None:
                self._invalid_transaction()
            self._dbapi_connection = self.engine.raw_connection()
            return self._dbapi_connection
>       raise exc.ResourceClosedError("This Connection is closed")
E       sqlalchemy.exc.ResourceClosedError: This Connection is closed

..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:679: ResourceClosedError
------------------------------ Captured log call ------------------------------
WARNING  root:unit_of_work.py:109 Exception in UnitOfWork, rolling back: This Connection is closed
____________ TestUnitOfWork.test_unit_of_work_transaction_rollback ____________

self = <test_unit_of_work.TestUnitOfWork object at 0x0000021CDE9F4250>
clean_db = (<sqlalchemy.orm.session.Session object at 0x0000021CE13430D0>, User(id=40, username='clean_db_testuser_7dc93b00', email=None, password_hash='hash', password=None, is_active=True, is_admin=True))

    def test_unit_of_work_transaction_rollback(self, clean_db):
        """Test that failed operations are rolled back."""
        session, domain_user = clean_db
    
        # First, create a department that will be used for conflict
        with UnitOfWork() as uow:
            department = Department(name="Conflict Department")
>           uow.departments.add(department)

tests\infrastructure\persistence\test_unit_of_work.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
infrastructure\persistence\sqlite\repositories.py:67: in add
    existing = self.get_by_name(department.name)
infrastructure\persistence\sqlite\repositories.py:101: in get_by_name
    department_orm = self.session.scalars(stmt).first()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2473: in scalars
    return self._execute_internal(
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2241: in _execute_internal
    conn = self._connection_for_bind(bind)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2110: in _connection_for_bind
    return trans._connection_for_bind(engine, execution_options)
<string>:2: in _connection_for_bind
    ???
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:1242: in _connection_for_bind
    transaction = conn.begin()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:859: in begin
    self._transaction = RootTransaction(self)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2681: in __init__
    self._connection_begin_impl()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2699: in _connection_begin_impl
    self.connection._begin_impl(self)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:1107: in _begin_impl
    self._handle_dbapi_exception(e, None, None, None, None)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise exc_info[1].with_traceback(exc_info[2])
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:1105: in _begin_impl
    self.engine.dialect.do_begin(self.connection)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:584: in connection
    return self._revalidate_connection()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.engine.base.Connection object at 0x0000021CDF97E850>

    def _revalidate_connection(self) -> PoolProxiedConnection:
        if self.__can_reconnect and self.invalidated:
            if self._transaction is not None:
                self._invalid_transaction()
            self._dbapi_connection = self.engine.raw_connection()
            return self._dbapi_connection
>       raise exc.ResourceClosedError("This Connection is closed")
E       sqlalchemy.exc.ResourceClosedError: This Connection is closed

..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:679: ResourceClosedError
------------------------------ Captured log call ------------------------------
WARNING  root:unit_of_work.py:109 Exception in UnitOfWork, rolling back: This Connection is closed
_______________ TestUnitOfWork.test_unit_of_work_manual_commit ________________

self = <test_unit_of_work.TestUnitOfWork object at 0x0000021CDE9F4890>
clean_db = (<sqlalchemy.orm.session.Session object at 0x0000021CE147A790>, User(id=40, username='clean_db_testuser_f9388e38', email=None, password_hash='hash', password=None, is_active=True, is_admin=True))

    def test_unit_of_work_manual_commit(self, clean_db):
        """Test manual commit functionality."""
        session, domain_user = clean_db
    
        # Test that manual commit works
        with UnitOfWork() as uow:
            # Add a department
            department = Department(name="Manual Commit Dept")
>           created_dept = uow.departments.add(department)

tests\infrastructure\persistence\test_unit_of_work.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
infrastructure\persistence\sqlite\repositories.py:67: in add
    existing = self.get_by_name(department.name)
infrastructure\persistence\sqlite\repositories.py:101: in get_by_name
    department_orm = self.session.scalars(stmt).first()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2473: in scalars
    return self._execute_internal(
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2241: in _execute_internal
    conn = self._connection_for_bind(bind)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2110: in _connection_for_bind
    return trans._connection_for_bind(engine, execution_options)
<string>:2: in _connection_for_bind
    ???
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:1242: in _connection_for_bind
    transaction = conn.begin()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:859: in begin
    self._transaction = RootTransaction(self)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2681: in __init__
    self._connection_begin_impl()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2699: in _connection_begin_impl
    self.connection._begin_impl(self)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:1107: in _begin_impl
    self._handle_dbapi_exception(e, None, None, None, None)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise exc_info[1].with_traceback(exc_info[2])
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:1105: in _begin_impl
    self.engine.dialect.do_begin(self.connection)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:584: in connection
    return self._revalidate_connection()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.engine.base.Connection object at 0x0000021CDF97E850>

    def _revalidate_connection(self) -> PoolProxiedConnection:
        if self.__can_reconnect and self.invalidated:
            if self._transaction is not None:
                self._invalid_transaction()
            self._dbapi_connection = self.engine.raw_connection()
            return self._dbapi_connection
>       raise exc.ResourceClosedError("This Connection is closed")
E       sqlalchemy.exc.ResourceClosedError: This Connection is closed

..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:679: ResourceClosedError
------------------------------ Captured log call ------------------------------
WARNING  root:unit_of_work.py:109 Exception in UnitOfWork, rolling back: This Connection is closed
______________ TestUnitOfWork.test_unit_of_work_manual_rollback _______________

self = <test_unit_of_work.TestUnitOfWork object at 0x0000021CDE9F4ED0>
clean_db = (<sqlalchemy.orm.session.Session object at 0x0000021CE1192910>, User(id=40, username='clean_db_testuser_5b165cb5', email=None, password_hash='hash', password=None, is_active=True, is_admin=True))

    def test_unit_of_work_manual_rollback(self, clean_db):
        """Test manual rollback functionality."""
        session, domain_user = clean_db
    
        with UnitOfWork() as uow:
            # Add a department
            department = Department(name="Manual Rollback Dept")
>           uow.departments.add(department)

tests\infrastructure\persistence\test_unit_of_work.py:168: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
infrastructure\persistence\sqlite\repositories.py:67: in add
    existing = self.get_by_name(department.name)
infrastructure\persistence\sqlite\repositories.py:101: in get_by_name
    department_orm = self.session.scalars(stmt).first()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2473: in scalars
    return self._execute_internal(
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2241: in _execute_internal
    conn = self._connection_for_bind(bind)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2110: in _connection_for_bind
    return trans._connection_for_bind(engine, execution_options)
<string>:2: in _connection_for_bind
    ???
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:1242: in _connection_for_bind
    transaction = conn.begin()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:859: in begin
    self._transaction = RootTransaction(self)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2681: in __init__
    self._connection_begin_impl()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2699: in _connection_begin_impl
    self.connection._begin_impl(self)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:1107: in _begin_impl
    self._handle_dbapi_exception(e, None, None, None, None)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise exc_info[1].with_traceback(exc_info[2])
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:1105: in _begin_impl
    self.engine.dialect.do_begin(self.connection)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:584: in connection
    return self._revalidate_connection()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.engine.base.Connection object at 0x0000021CDF97E850>

    def _revalidate_connection(self) -> PoolProxiedConnection:
        if self.__can_reconnect and self.invalidated:
            if self._transaction is not None:
                self._invalid_transaction()
            self._dbapi_connection = self.engine.raw_connection()
            return self._dbapi_connection
>       raise exc.ResourceClosedError("This Connection is closed")
E       sqlalchemy.exc.ResourceClosedError: This Connection is closed

..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:679: ResourceClosedError
------------------------------ Captured log call ------------------------------
WARNING  root:unit_of_work.py:109 Exception in UnitOfWork, rolling back: This Connection is closed
_____________ TestUnitOfWork.test_unit_of_work_complex_operation ______________

self = <test_unit_of_work.TestUnitOfWork object at 0x0000021CDE9F5510>
clean_db = (<sqlalchemy.orm.session.Session object at 0x0000021CE14BCCD0>, User(id=40, username='clean_db_testuser_8a6bffd7', email=None, password_hash='hash', password=None, is_active=True, is_admin=True))

    def test_unit_of_work_complex_operation(self, clean_db):
        """Test a complex operation involving multiple repositories."""
        session, domain_user = clean_db
    
        with UnitOfWork() as uow:
            # Create customer
            customer = Customer(
                name="UoW Test Customer",
                email="uow@test.com",
                phone="123-456-7890",
                cuit="12345678"
            )
>           created_customer = uow.customers.add(customer)

tests\infrastructure\persistence\test_unit_of_work.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
infrastructure\persistence\sqlite\repositories.py:872: in add
    existing_cuit = self.session.execute(
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2365: in execute
    return self._execute_internal(
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2241: in _execute_internal
    conn = self._connection_for_bind(bind)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:2110: in _connection_for_bind
    return trans._connection_for_bind(engine, execution_options)
<string>:2: in _connection_for_bind
    ???
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\state_changes.py:139: in _go
    ret_value = fn(self, *arg, **kw)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\orm\session.py:1242: in _connection_for_bind
    transaction = conn.begin()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:859: in begin
    self._transaction = RootTransaction(self)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2681: in __init__
    self._connection_begin_impl()
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2699: in _connection_begin_impl
    self.connection._begin_impl(self)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:1107: in _begin_impl
    self._handle_dbapi_exception(e, None, None, None, None)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise exc_info[1].with_traceback(exc_info[2])
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:1105: in _begin_impl
    self.engine.dialect.do_begin(self.connection)
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:584: in connection
    return self._revalidate_connection()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.engine.base.Connection object at 0x0000021CDF97E850>

    def _revalidate_connection(self) -> PoolProxiedConnection:
        if self.__can_reconnect and self.invalidated:
            if self._transaction is not None:
                self._invalid_transaction()
            self._dbapi_connection = self.engine.raw_connection()
            return self._dbapi_connection
>       raise exc.ResourceClosedError("This Connection is closed")
E       sqlalchemy.exc.ResourceClosedError: This Connection is closed

..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\sqlalchemy\engine\base.py:679: ResourceClosedError
------------------------------ Captured log call ------------------------------
ERROR    root:repositories.py:928 Error adding customer: This Connection is closed
WARNING  root:unit_of_work.py:109 Exception in UnitOfWork, rolling back: This Connection is closed
___________________________ test_simple_db_session ____________________________

clean_db = (<sqlalchemy.orm.session.Session object at 0x0000021CE135F090>, User(id=40, username='clean_db_testuser_c536a3a0', email=None, password_hash='hash', password=None, is_active=True, is_admin=True))

    @pytest.mark.integration
    def test_simple_db_session(clean_db):
        """Test that we can get a clean database session."""
        # clean_db returns (session, user) tuple
        session, user = clean_db
    
        assert session is not None, "Clean database session should be available"
    
        # Try a simple operation using proper SQLAlchemy text() function
        # that doesn't rely on any particular table existing
        result = session.execute(text("SELECT 1")).scalar()
        assert result == 1, "Basic SQL query should work"
    
        # Verify user was created correctly
>       assert user.username == "testuser", "Test user should have correct username"
E       AssertionError: Test user should have correct username
E       assert 'clean_db_testuser_c536a3a0' == 'testuser'
E         
E         - testuser
E         + clean_db_testuser_c536a3a0

tests\integration\test_db_simple.py:35: AssertionError
______________ TestSalesEndToEndFlow.test_complete_sale_process _______________

self = <tests.integration.test_end_to_end_flows.TestSalesEndToEndFlow object at 0x0000021CDF5CD210>
test_app = {'external': {'filesystem': <external_service_mocks.mock_file_system.<locals>.MockFileSystem object at 0x0000021CE1470650>, 'http': <MagicMock id='2323061962128'>}, 'get_session': <function test_app.<locals>.get_session_context at 0x0000021CE1425260>, 'repositories': {'customer_repo': <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CE1472E50>, 'invoice_repo': <infrastructure.persistence.sqlite.repositories.SqliteInvoiceRepository object at 0x0000021CE1472AD0>, 'product_repo': <infrastructure.persistence.sqlite.repositories.SqliteProductRepository object at 0x0000021CE1472890>, 'sale_repo': <infrastructure.persistence.sqlite.repositories.SqliteSaleRepository object at 0x0000021CE1472A90>}, 'services': {'customer_service': <tests.integration.conftest.test_app.<locals>.TestCustomerService object at 0x0000021CE14712D0>, 'inventory_service': <MagicMock id='2323061871888'>, 'invoicing_service': <tests.integration.conftest.test_app.<locals>.TestInvoicingService object at 0x0000021CE1472250>, 'product_service': <tests.integration.conftest.test_app.<locals>.TestProductService object at 0x0000021CE1471250>, ...}, ...}
test_data_factory = <tests.integration.conftest.test_data_factory.<locals>.TestDataFactory object at 0x0000021CE1472D90>

    def test_complete_sale_process(self, test_app, test_data_factory):
        """
        Test a complete sale from product selection to receipt generation.
    
        This test verifies:
        - Product creation and retrieval
        - Inventory stock updates when sale happens
        - Customer selection and association
        - Sale creation with multiple items
        - Receipt generation
        """
        # Get services from the test app
        product_service = test_app["services"]["product_service"]
        sale_service = test_app["services"]["sale_service"]
        inventory_service = test_app["services"]["inventory_service"]
        customer_service = test_app["services"]["customer_service"]
    
        # Create test products
        product1 = test_data_factory.create_product(
            code="PROD001",
            description="Test Product 1",
            sell_price=100.00,
            quantity_in_stock=10
        )
    
        product2 = test_data_factory.create_product(
            code="PROD002",
            description="Test Product 2",
            sell_price=150.00,
            quantity_in_stock=5
        )
    
        # Create a test customer
        customer = test_data_factory.create_customer(
            name="End-to-End Test Customer",
            email="endtoend@test.com"
        )
    
        # Create a test user to ensure users table exists
        user = test_data_factory.create_user(
            username="test_sales_user",
            password_hash="$2b$12$test_hash_for_sales_process"
        )
    
        # Use the authenticated user from the test_app fixture
        # user = test_app["user"]  # Comment this out to use our newly created user instead
    
        # Setup inventory service mock for verification
        original_update_stock = inventory_service.update_stock_from_sale
        inventory_service.update_stock_from_sale = MagicMock()
    
        # Patch customer service to handle our test customer ID
        def mock_get_customer_by_id(customer_id):
            if customer_id == customer.id:
                return customer
            return None
    
        # Commit the session after creating test data to make it visible in the service's transaction
        test_app["session"].commit()
    
        # ---> ADD VERIFICATION HERE <---
        # Verify customer exists in the session *before* calling create_sale
        retrieved_customer_orm = test_app["session"].query(CustomerOrm).filter(CustomerOrm.id == customer.id).first()
        assert retrieved_customer_orm is not None, f"Customer {customer.id} not found in session before calling create_sale"
        assert str(retrieved_customer_orm.id) == str(customer.id)
    
        # Patch the customer_service.get_customer_by_id method on the instance within test_app
        # Note: This patch might be redundant now if committing solves the visibility issue, but keep for now.
        with patch.object(test_app["services"]["customer_service"], 'get_customer_by_id', side_effect=mock_get_customer_by_id):
    
            # Create a sale with multiple items
            sale_items = [
                {
                    "product_id": product1.id,
                    "product_code": product1.code,
                    "product_description": product1.description,
                    "quantity": 2,
                    "unit_price": product1.sell_price
                },
                {
                    "product_id": product2.id,
                    "product_code": product2.code,
                    "product_description": product2.description,
                    "quantity": 1,
                    "unit_price": product2.sell_price
                }
            ]
    
            # Process the sale - include user_id and payment_type
>           sale = sale_service.create_sale(
                items_data=sale_items,
                customer_id=customer.id,
                user_id=user.id,
                payment_type='Efectivo'
                )

tests\integration\test_end_to_end_flows.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
core\services\sale_service.py:34: in create_sale
    with unit_of_work() as uow:
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.2544.0_x64__qbz5n2kfra8p0\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
infrastructure\persistence\unit_of_work.py:195: in unit_of_work
    with UnitOfWork() as uow:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.unit_of_work.UnitOfWork object at 0x0000021CE141D190>

    def __enter__(self):
        """Enter the Unit of Work context.
    
        Creates a new database session and initializes all repositories
        with the shared session.
    
        Returns:
            UnitOfWork: The Unit of Work instance with initialized repositories.
        """
        if self.session_factory is None:
>           raise ValueError(
                "No session factory has been set. Make sure to call "
                "session_scope_provider.set_default_session_factory() first."
            )
E           ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.

infrastructure\persistence\unit_of_work.py:68: ValueError
_____________ TestSalesEndToEndFlow.test_sale_with_error_handling _____________

self = <tests.integration.test_end_to_end_flows.TestSalesEndToEndFlow object at 0x0000021CDF5CD610>
test_app = {'external': {'filesystem': <external_service_mocks.mock_file_system.<locals>.MockFileSystem object at 0x0000021CE1359950>, 'http': <MagicMock id='2323060854608'>}, 'get_session': <function test_app.<locals>.get_session_context at 0x0000021CE14256C0>, 'repositories': {'customer_repo': <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CE1472910>, 'invoice_repo': <infrastructure.persistence.sqlite.repositories.SqliteInvoiceRepository object at 0x0000021CE1470F10>, 'product_repo': <infrastructure.persistence.sqlite.repositories.SqliteProductRepository object at 0x0000021CE14DBC10>, 'sale_repo': <infrastructure.persistence.sqlite.repositories.SqliteSaleRepository object at 0x0000021CE1470690>}, 'services': {'customer_service': <tests.integration.conftest.test_app.<locals>.TestCustomerService object at 0x0000021CE1359B50>, 'inventory_service': <MagicMock id='2323060732432'>, 'invoicing_service': <tests.integration.conftest.test_app.<locals>.TestInvoicingService object at 0x0000021CE14DBED0>, 'product_service': <tests.integration.conftest.test_app.<locals>.TestProductService object at 0x0000021CE135BE10>, ...}, ...}
test_data_factory = <tests.integration.conftest.test_data_factory.<locals>.TestDataFactory object at 0x0000021CE1473150>

    def test_sale_with_error_handling(self, test_app, test_data_factory):
        """
        Test error handling during sale processing.
    
        This test verifies that:
        - Inventory can be properly tracked
        - We can catch and handle error conditions
        """
        # Get the session and services from test_app
        session = test_app["session"]
        product_service = test_app["services"]["product_service"]
        inventory_service = test_app["services"]["inventory_service"]
    
        # Create a product with limited stock
        product = test_data_factory.create_product(
            code="LIMITED",
            description="Limited Stock Product",
            sell_price=100.00,
            quantity_in_stock=3
        )
    
        # Flush changes to make them available within the transaction
        session.flush()
    
        # Manually verify the product exists and has the correct stock
>       retrieved_product = product_service.get_product_by_id(product.id)

tests\integration\test_end_to_end_flows.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
core\services\product_service.py:144: in get_product_by_id
    with unit_of_work() as uow:
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.2544.0_x64__qbz5n2kfra8p0\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
infrastructure\persistence\unit_of_work.py:195: in unit_of_work
    with UnitOfWork() as uow:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.unit_of_work.UnitOfWork object at 0x0000021CE13776D0>

    def __enter__(self):
        """Enter the Unit of Work context.
    
        Creates a new database session and initializes all repositories
        with the shared session.
    
        Returns:
            UnitOfWork: The Unit of Work instance with initialized repositories.
        """
        if self.session_factory is None:
>           raise ValueError(
                "No session factory has been set. Make sure to call "
                "session_scope_provider.set_default_session_factory() first."
            )
E           ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.

infrastructure\persistence\unit_of_work.py:68: ValueError
_________ TestInvoicingEndToEndFlow.test_invoice_generation_from_sale _________

self = <tests.integration.test_end_to_end_flows.TestInvoicingEndToEndFlow object at 0x0000021CDF5CDF90>
test_app = {'external': {'filesystem': <external_service_mocks.mock_file_system.<locals>.MockFileSystem object at 0x0000021CE1387A10>, 'http': <MagicMock id='2323060409424'>}, 'get_session': <function test_app.<locals>.get_session_context at 0x0000021CE1427380>, 'repositories': {'customer_repo': <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CE1386150>, 'invoice_repo': <infrastructure.persistence.sqlite.repositories.SqliteInvoiceRepository object at 0x0000021CE1385E50>, 'product_repo': <infrastructure.persistence.sqlite.repositories.SqliteProductRepository object at 0x0000021CE1385AD0>, 'sale_repo': <infrastructure.persistence.sqlite.repositories.SqliteSaleRepository object at 0x0000021CE1385C10>}, 'services': {'customer_service': <tests.integration.conftest.test_app.<locals>.TestCustomerService object at 0x0000021CE1387210>, 'inventory_service': <MagicMock id='2323060913040'>, 'invoicing_service': <tests.integration.conftest.test_app.<locals>.TestInvoicingService object at 0x0000021CE1386090>, 'product_service': <tests.integration.conftest.test_app.<locals>.TestProductService object at 0x0000021CE13873D0>, ...}, ...}
test_data_factory = <tests.integration.conftest.test_data_factory.<locals>.TestDataFactory object at 0x0000021CE1385E10>

    def test_invoice_generation_from_sale(self, test_app, test_data_factory):
        """
        Test complete invoice creation from a sale.
    
        This test verifies:
        - Sale creation with proper customer data
        - Invoice generation from the sale
        - PDF generation from invoice
        - Correct data propagation from sale to invoice
        """
        # Get services from the test app
        product_service = test_app["services"]["product_service"]
        sale_service = test_app["services"]["sale_service"]
        invoicing_service = test_app["services"]["invoicing_service"]
        customer_service = test_app["services"]["customer_service"]
        session = test_app["session"]
    
        # Create a test customer eligible for proper invoicing
>       customer = test_data_factory.create_customer(
            name="Invoice Customer",
            email="invoice@example.com",
            cuit="20-12345678-9",
            iva_condition="Responsable Inscripto"
        )

tests\integration\test_end_to_end_flows.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\integration\conftest.py:316: in create_customer
    customer = customer_repo.add(customer)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CE1385CD0>
customer = Customer(name='Invoice Customer', id=UUID('88c2ec90-d4b4-40dc-bcb8-080a2ba045d1'), phone='1234567890', email='invoice@example.com', address='123 Test St', cuit='20-12345678-9', iva_condition='Responsable Inscripto', credit_limit=0.0, credit_balance=0.0, is_active=True)

    def add(self, customer: Customer) -> Customer:
        """Add a new customer to the repository."""
        try:
            # Check for duplicate CUIT
            if customer.cuit:  # Only check if CUIT is provided
                existing_cuit = self.session.execute(
                    text("SELECT id FROM customers WHERE cuit = :cuit"),
                    {"cuit": customer.cuit}
                ).scalar_one_or_none()
    
                if existing_cuit:
>                   raise ValueError(f"Customer with CUIT {customer.cuit} already exists")
E                   ValueError: Customer with CUIT 20-12345678-9 already exists

infrastructure\persistence\sqlite\repositories.py:878: ValueError
---------------------------- Captured stdout setup ----------------------------
Verifying mapping for 10 models...
Tables currently in Base.metadata: ['users', 'departments', 'products', 'inventory_movements', 'sales', 'sale_items', 'customers', 'credit_payments', 'invoices', 'cash_drawer_entries', 'test_items']
  - Model UserOrm correctly mapped to table 'users'
  - Model DepartmentOrm correctly mapped to table 'departments'
  - Model ProductOrm correctly mapped to table 'products'
  - Model InventoryMovementOrm correctly mapped to table 'inventory_movements'
  - Model SaleOrm correctly mapped to table 'sales'
  - Model SaleItemOrm correctly mapped to table 'sale_items'
  - Model CustomerOrm correctly mapped to table 'customers'
  - Model CreditPaymentOrm correctly mapped to table 'credit_payments'
  - Model InvoiceOrm correctly mapped to table 'invoices'
  - Model CashDrawerEntryOrm correctly mapped to table 'cash_drawer_entries'
Successfully verified 10 models mapped to 11 tables in Base.metadata.
All models mapped for TestInvoicingEndToEndFlow tests
------------------------------ Captured log call ------------------------------
ERROR    root:repositories.py:928 Error adding customer: Customer with CUIT 20-12345678-9 already exists
__________ TestConcurrencyAndEdgeCases.test_simple_product_creation ___________

self = <tests.integration.test_end_to_end_flows.TestConcurrencyAndEdgeCases object at 0x0000021CDF5CEFD0>
test_app = {'external': {'filesystem': <external_service_mocks.mock_file_system.<locals>.MockFileSystem object at 0x0000021CE1479F10>, 'http': <MagicMock id='2323061499344'>}, 'get_session': <function test_app.<locals>.get_session_context at 0x0000021CE1424AE0>, 'repositories': {'customer_repo': <infrastructure.persistence.sqlite.repositories.SqliteCustomerRepository object at 0x0000021CDF88CA90>, 'invoice_repo': <infrastructure.persistence.sqlite.repositories.SqliteInvoiceRepository object at 0x0000021CDF88F6D0>, 'product_repo': <infrastructure.persistence.sqlite.repositories.SqliteProductRepository object at 0x0000021CDF88E790>, 'sale_repo': <infrastructure.persistence.sqlite.repositories.SqliteSaleRepository object at 0x0000021CDF88DA10>}, 'services': {'customer_service': <tests.integration.conftest.test_app.<locals>.TestCustomerService object at 0x0000021CE1479DD0>, 'inventory_service': <MagicMock id='2323061901392'>, 'invoicing_service': <tests.integration.conftest.test_app.<locals>.TestInvoicingService object at 0x0000021CDF88F150>, 'product_service': <tests.integration.conftest.test_app.<locals>.TestProductService object at 0x0000021CE1479050>, ...}, ...}
test_data_factory = <tests.integration.conftest.test_data_factory.<locals>.TestDataFactory object at 0x0000021CE1387A50>

    @pytest.mark.integration
    def test_simple_product_creation(self, test_app, test_data_factory):
        """
        A simple test to verify product creation works correctly.
        This serves as a basic sanity check for database operations.
        """
        # Get the session from test_app
        session = test_app["session"]
    
        # Create a test user to ensure users table exists
        user = test_data_factory.create_user(
            username="test_product_creation_user",
            password_hash="$2b$12$test_hash_for_product_creation"
        )
    
        # Flush changes to make sure the user is available within the transaction
        session.flush()
    
        # Get product service
        product_service = test_app["services"]["product_service"]
    
        # Create a simple product
        product = test_data_factory.create_product(
            code="SIMPLE001",
            description="Simple Test Product",
            sell_price=50.00,
            cost_price=25.00,
            quantity_in_stock=100
        )
    
        # Print product ID and details for debugging
        print(f"Created product ID: {product.id}, type: {type(product.id)}")
    
        # Flush changes to make sure the product is available within the transaction
        session.flush()
    
        # Try directly querying the database to verify product existence
        from infrastructure.persistence.sqlite.models_mapping import ProductOrm
        from sqlalchemy import select
    
        stmt = select(ProductOrm).where(ProductOrm.id == product.id)
        result = session.execute(stmt).scalar_one_or_none()
    
        print(f"Direct DB query result: {result}")
        if result:
            print(f"Product in DB: ID={result.id}, Code={result.code}")
    
        # ---- Test 1: Use the service's method without session (should work with factory pattern) ----
        # The product_service is configured to use the test session via the factory pattern
>       retrieved_product = product_service.get_product_by_id(product.id)

tests\integration\test_end_to_end_flows.py:623: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
core\services\product_service.py:144: in get_product_by_id
    with unit_of_work() as uow:
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.2544.0_x64__qbz5n2kfra8p0\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
infrastructure\persistence\unit_of_work.py:195: in unit_of_work
    with UnitOfWork() as uow:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.unit_of_work.UnitOfWork object at 0x0000021CE1939C90>

    def __enter__(self):
        """Enter the Unit of Work context.
    
        Creates a new database session and initializes all repositories
        with the shared session.
    
        Returns:
            UnitOfWork: The Unit of Work instance with initialized repositories.
        """
        if self.session_factory is None:
>           raise ValueError(
                "No session factory has been set. Make sure to call "
                "session_scope_provider.set_default_session_factory() first."
            )
E           ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.

infrastructure\persistence\unit_of_work.py:68: ValueError
---------------------------- Captured stdout call -----------------------------
Created product ID: 24, type: <class 'int'>
Direct DB query result: <ProductOrm(id=24, code='SIMPLE001', description='Simple Test Product')>
Product in DB: ID=24, Code=SIMPLE001
__________ TestUserIntegration.test_add_user_valid_user_returns_user __________

self = <tests.integration.test_user_integration.TestUserIntegration object at 0x0000021CDF5DCA90>
user_service = <core.services.user_service.UserService object at 0x0000021CE1409B50>

    def test_add_user_valid_user_returns_user(self, user_service):
        """
        Test that adding a valid user returns a User object with an assigned ID
        and correct username and active status.
        """
        # Use timestamp to ensure unique username
        timestamp = int(time.time() * 1000)
        username = f"johndoe_{timestamp}"
    
>       new_user = user_service.add_user(username, "password123")

tests\integration\test_user_integration.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
core\services\user_service.py:37: in add_user
    with unit_of_work() as uow:
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.2544.0_x64__qbz5n2kfra8p0\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
infrastructure\persistence\unit_of_work.py:195: in unit_of_work
    with UnitOfWork() as uow:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.unit_of_work.UnitOfWork object at 0x0000021CE1141F10>

    def __enter__(self):
        """Enter the Unit of Work context.
    
        Creates a new database session and initializes all repositories
        with the shared session.
    
        Returns:
            UnitOfWork: The Unit of Work instance with initialized repositories.
        """
        if self.session_factory is None:
>           raise ValueError(
                "No session factory has been set. Make sure to call "
                "session_scope_provider.set_default_session_factory() first."
            )
E           ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.

infrastructure\persistence\unit_of_work.py:68: ValueError
---------------------------- Captured stdout setup ----------------------------
Verifying mapping for 10 models...
Tables currently in Base.metadata: ['users', 'departments', 'products', 'inventory_movements', 'sales', 'sale_items', 'customers', 'credit_payments', 'invoices', 'cash_drawer_entries', 'test_items']
  - Model UserOrm correctly mapped to table 'users'
  - Model DepartmentOrm correctly mapped to table 'departments'
  - Model ProductOrm correctly mapped to table 'products'
  - Model InventoryMovementOrm correctly mapped to table 'inventory_movements'
  - Model SaleOrm correctly mapped to table 'sales'
  - Model SaleItemOrm correctly mapped to table 'sale_items'
  - Model CustomerOrm correctly mapped to table 'customers'
  - Model CreditPaymentOrm correctly mapped to table 'credit_payments'
  - Model InvoiceOrm correctly mapped to table 'invoices'
  - Model CashDrawerEntryOrm correctly mapped to table 'cash_drawer_entries'
Successfully verified 10 models mapped to 11 tables in Base.metadata.
All models mapped for TestUserIntegration tests
___ TestUserIntegration.test_add_user_duplicate_username_raises_value_error ___

self = <tests.integration.test_user_integration.TestUserIntegration object at 0x0000021CDF5F3290>
user_service = <core.services.user_service.UserService object at 0x0000021CDF88F910>

    def test_add_user_duplicate_username_raises_value_error(self, user_service):
        """
        Test that adding a user with a duplicate username raises a ValueError.
        """
        # Use timestamp to ensure unique username for first user
        timestamp = int(time.time() * 1000)
        username = f"dupuser_{timestamp}"
    
>       user_service.add_user(username, "pass1")

tests\integration\test_user_integration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
core\services\user_service.py:37: in add_user
    with unit_of_work() as uow:
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.2544.0_x64__qbz5n2kfra8p0\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
infrastructure\persistence\unit_of_work.py:195: in unit_of_work
    with UnitOfWork() as uow:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.unit_of_work.UnitOfWork object at 0x0000021CDF88F390>

    def __enter__(self):
        """Enter the Unit of Work context.
    
        Creates a new database session and initializes all repositories
        with the shared session.
    
        Returns:
            UnitOfWork: The Unit of Work instance with initialized repositories.
        """
        if self.session_factory is None:
>           raise ValueError(
                "No session factory has been set. Make sure to call "
                "session_scope_provider.set_default_session_factory() first."
            )
E           ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.

infrastructure\persistence\unit_of_work.py:68: ValueError
__ TestUserIntegration.test_authenticate_user_valid_credentials_returns_user __

self = <tests.integration.test_user_integration.TestUserIntegration object at 0x0000021CDF5F3610>
user_service = <core.services.user_service.UserService object at 0x0000021CE142EC50>

    def test_authenticate_user_valid_credentials_returns_user(self, user_service):
        """
        Test that authenticating with correct credentials returns the User.
        """
        # Use timestamp to ensure unique username
        timestamp = int(time.time() * 1000)
        username = f"authuser_{timestamp}"
    
>       created_user = user_service.add_user(username, "secret")

tests\integration\test_user_integration.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
core\services\user_service.py:37: in add_user
    with unit_of_work() as uow:
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.2544.0_x64__qbz5n2kfra8p0\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
infrastructure\persistence\unit_of_work.py:195: in unit_of_work
    with UnitOfWork() as uow:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.unit_of_work.UnitOfWork object at 0x0000021CE142DFD0>

    def __enter__(self):
        """Enter the Unit of Work context.
    
        Creates a new database session and initializes all repositories
        with the shared session.
    
        Returns:
            UnitOfWork: The Unit of Work instance with initialized repositories.
        """
        if self.session_factory is None:
>           raise ValueError(
                "No session factory has been set. Make sure to call "
                "session_scope_provider.set_default_session_factory() first."
            )
E           ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.

infrastructure\persistence\unit_of_work.py:68: ValueError
_ TestUserIntegration.test_authenticate_user_invalid_credentials_returns_none _

self = <tests.integration.test_user_integration.TestUserIntegration object at 0x0000021CDF5F39D0>
user_service = <core.services.user_service.UserService object at 0x0000021CE1486ED0>

    def test_authenticate_user_invalid_credentials_returns_none(self, user_service):
        """
        Test that authentication with invalid credentials returns None.
        """
        # Use timestamp to ensure unique username
        timestamp = int(time.time() * 1000)
        username = f"authfail_{timestamp}"
    
>       user_service.add_user(username, "goodpass")

tests\integration\test_user_integration.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
core\services\user_service.py:37: in add_user
    with unit_of_work() as uow:
C:\Program Files\WindowsApps\PythonSoftwareFoundation.Python.3.11_3.11.2544.0_x64__qbz5n2kfra8p0\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
infrastructure\persistence\unit_of_work.py:195: in unit_of_work
    with UnitOfWork() as uow:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <infrastructure.persistence.unit_of_work.UnitOfWork object at 0x0000021CE1487190>

    def __enter__(self):
        """Enter the Unit of Work context.
    
        Creates a new database session and initializes all repositories
        with the shared session.
    
        Returns:
            UnitOfWork: The Unit of Work instance with initialized repositories.
        """
        if self.session_factory is None:
>           raise ValueError(
                "No session factory has been set. Make sure to call "
                "session_scope_provider.set_default_session_factory() first."
            )
E           ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.

infrastructure\persistence\unit_of_work.py:68: ValueError
============================== warnings summary ===============================
..\..\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\PySide6\QtTest.pyd:0
  C:\Users\Jonandrop\AppData\Local\Packages\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\LocalCache\local-packages\Python311\site-packages\PySide6\QtTest.pyd:0: PytestCollectionWarning: cannot collect test class 'QTest' because it has a __new__ constructor (from: tests/ui/dialogs/test_error_dialog.py)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=============================== tests coverage ================================
_______________ coverage: platform win32, python 3.11.9-final-0 _______________

Name                                       Stmts   Miss  Cover
--------------------------------------------------------------
core\__init__.py                               1      0   100%
core\exceptions.py                            32      3    91%
core\interfaces\__init__.py                    0      0   100%
core\interfaces\repository_interfaces.py     147      8    95%
core\models\__init__.py                        9      0   100%
core\models\cash_drawer.py                    21      0   100%
core\models\credit_payment.py                 13      0   100%
core\models\customer.py                       15      0   100%
core\models\department.py                      7      0   100%
core\models\error_models.py                    9      0   100%
core\models\inventory.py                      14      0   100%
core\models\invoice.py                        21      0   100%
core\models\product.py                        45      1    98%
core\models\sale.py                           35      0   100%
core\models\user.py                           10      0   100%
core\services\__init__.py                      0      0   100%
core\services\cash_drawer_service.py          65      8    88%
core\services\corte_service.py                45      1    98%
core\services\customer_service.py            135     31    77%
core\services\inventory_service.py            78      2    97%
core\services\invoicing_service.py           205     33    84%
core\services\product_service.py             152     10    93%
core\services\reporting_service.py           171     14    92%
core\services\sale_service.py                164    112    32%
core\services\service_base.py                  6      0   100%
core\services\user_service.py                 16      1    94%
core\utils\__init__.py                         1      0   100%
core\utils\validation.py                      21      0   100%
--------------------------------------------------------------
TOTAL                                       1438    224    84%
Coverage HTML written to dir htmlcov
=========================== short test summary info ===========================
FAILED tests/infrastructure/persistence/test_cash_drawer_repository.py::TestSQLiteCashDrawerRepository::test_get_last_start_entry_none - AssertionError: assert CashDrawerEntry(id=3, timestamp=datetime.datetime(2025, 7, 18, 14, 54, 22, 902710), entry_type=<CashDrawerEntryType.START: 'START'>, amount=Decimal('100.00'), description='Test entry', user_id=1, drawer_id=1) is None
FAILED tests/infrastructure/persistence/test_customer_repository.py::test_get_customer_by_id - ValueError: Customer with email test.customer@test.com already exists
FAILED tests/infrastructure/persistence/test_customer_repository.py::test_get_customer_by_cuit - ValueError: Customer with email test.customer@test.com already exists
FAILED tests/infrastructure/persistence/test_customer_repository.py::test_get_all_customers - AssertionError: assert 7 == 3
 +  where 7 = len([Customer(name='Customer Alpha', id=UUID('bfd85df2-1a21-43b5-b812-67f02f59479f'), phone=None, email='customer.alpha@test.com', address=None, cuit='1', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer Beta', id=UUID('87a464cd-341d-4ae3-b9ba-9804e416446b'), phone=None, email='customer.beta@test.com', address=None, cuit='2', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer Gamma', id=UUID('7ede1315-70e9-4a7c-8ecc-f26568ea8c2b'), phone=None, email='customer.gamma@test.com', address=None, cuit='3', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='First User', id=UUID('7c33e852-fa4e-425c-8eef-0a90580043e5'), phone=None, email='unique.email@example.com', address=None, cuit='10101010', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Test Customer', id=UUID('9744baa8-02f4-4a69-af1d-1cb51052aa4f'), phone='555-1234', email='test@example.com', address='123 Test St', cuit='20-12345678-9', iva_condition='Responsable Inscripto', credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Test Customer', id=UUID('8d0fe505-1ba2-4037-a72c-fb4f974a9330'), phone='555-1234', email='test1752843263@example.com', address='123 Test St', cuit='201752843263', iva_condition='Responsable Inscripto', credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Test Customer', id=UUID('6860cd86-31a7-499b-8165-a0c7ab50f4a6'), phone=None, email='test.customer@test.com', address=None, cuit='99887766', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True)])
FAILED tests/infrastructure/persistence/test_customer_repository.py::test_update_customer - ValueError: Customer with email test.customer@test.com already exists
FAILED tests/infrastructure/persistence/test_customer_repository.py::test_delete_customer - ValueError: Customer with email test.customer@test.com already exists
FAILED tests/infrastructure/persistence/test_customer_repository.py::test_get_all_customers_pagination - AssertionError: assert 10 == 5
 +  where 10 = len([Customer(name='Customer 4', id=UUID('12a6f7c6-e56f-4985-b0b1-143bde39fe87'), phone=None, email='customer.4@test.com', address=None, cuit='1004', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer 5', id=UUID('da1d047c-6fc9-4a59-a17e-cf9c81e03826'), phone=None, email='customer.5@test.com', address=None, cuit='1005', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer 6', id=UUID('4402dccd-bd06-4821-86d9-71e5ef920876'), phone=None, email='customer.6@test.com', address=None, cuit='1006', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer 7', id=UUID('531da55a-8667-49ca-ae5d-9f951559c078'), phone=None, email='customer.7@test.com', address=None, cuit='1007', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer 8', id=UUID('8fdee18d-aa2a-4bd9-a0d9-bd2cde3dd496'), phone=None, email='customer.8@test.com', address=None, cuit='1008', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer 9', id=UUID('5b918b1c-cd10-4d27-af45-ecec7de3339c'), phone=None, email='customer.9@test.com', address=None, cuit='1009', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer Alpha', id=UUID('bfd85df2-1a21-43b5-b812-67f02f59479f'), phone=None, email='customer.alpha@test.com', address=None, cuit='1', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer Beta', id=UUID('87a464cd-341d-4ae3-b9ba-9804e416446b'), phone=None, email='customer.beta@test.com', address=None, cuit='2', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='Customer Gamma', id=UUID('7ede1315-70e9-4a7c-8ecc-f26568ea8c2b'), phone=None, email='customer.gamma@test.com', address=None, cuit='3', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True), Customer(name='First User', id=UUID('7c33e852-fa4e-425c-8eef-0a90580043e5'), phone=None, email='unique.email@example.com', address=None, cuit='10101010', iva_condition=None, credit_limit=Decimal('0.00'), credit_balance=Decimal('0.00'), is_active=True)])
FAILED tests/infrastructure/persistence/test_customer_repository.py::test_search_customers_filtering_and_sorting - ValueError: Customer with CUIT 1001 already exists
FAILED tests/infrastructure/persistence/test_product_repository.py::test_get_all_products - AssertionError: assert 5 == 2
 +  where 5 = len([Product(id=4, code='ALL01', description='All Prod 1', cost_price=Decimal('0.00'), sell_price=Decimal('0.00'), wholesale_price=None, special_price=None, department_id=7, department=Department(id=7, name='Testing Dept', description=None), unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('0.000'), min_stock=Decimal('0.000'), max_stock=None, uses_inventory=True, is_service=False), Product(id=5, code='ALL02', description='All Prod 2', cost_price=Decimal('0.00'), sell_price=Decimal('0.00'), wholesale_price=None, special_price=None, department_id=7, department=Department(id=7, name='Testing Dept', description=None), unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('0.000'), min_stock=Decimal('0.000'), max_stock=None, uses_inventory=True, is_service=False), Product(id=1, code='P001', description='Test Product', cost_price=Decimal('50.00'), sell_price=Decimal('100.00'), wholesale_price=None, special_price=None, department_id=None, department=None, unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('10.000'), min_stock=Decimal('1.000'), max_stock=None, uses_inventory=True, is_service=False), Product(id=2, code='TESTPROD', description='Test Product', cost_price=Decimal('10.00'), sell_price=Decimal('20.00'), wholesale_price=None, special_price=None, department_id=None, department=None, unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('0.000'), min_stock=Decimal('0.000'), max_stock=None, uses_inventory=True, is_service=False), Product(id=3, code='TESTPROD2', description='Test Product 2', cost_price=Decimal('5.00'), sell_price=Decimal('15.00'), wholesale_price=None, special_price=None, department_id=None, department=None, unit='Unidad', barcode=None, brand=None, model=None, notes=None, created_at=None, updated_at=None, last_updated=None, is_active=True, quantity_in_stock=Decimal('0.000'), min_stock=Decimal('0.000'), max_stock=None, uses_inventory=True, is_service=False)])
FAILED tests/infrastructure/persistence/test_sale_repository.py::test_get_sales_by_payment_type - AssertionError: assert 3 == 2
 +  where 3 = len([{'payment_type': 'cash', 'total_sales': 200.0, 'num_sales': 1}, {'payment_type': 'CARD', 'total_sales': 30.0, 'num_sales': 3}, {'payment_type': 'CASH', 'total_sales': 20.0, 'num_sales': 2}])
FAILED tests/infrastructure/persistence/test_sale_repository.py::test_get_sales_by_customer - AssertionError: assert 3 == 2
 +  where 3 = len([{'customer_id': UUID('9744baa8-02f4-4a69-af1d-1cb51052aa4f'), 'customer_name': 'Test Customer', 'total_sales': 200.0, 'num_sales': 1}, {'customer_id': UUID('45122714-3557-4627-9245-c4c99cb4287d'), 'customer_name': 'Customer One 1752843264639', 'total_sales': 50.0, 'num_sales': 2}, {'customer_id': UUID('51d542df-a546-49fb-b0b8-40a5e67f160c'), 'customer_name': 'Customer Two 1752843264653', 'total_sales': 10.0, 'num_sales': 1}])
FAILED tests/infrastructure/persistence/test_sale_repository.py::test_get_top_selling_products - AssertionError: assert 4 == 3
 +  where 4 = len([{'product_id': 13, 'product_code': 'TOP1_1752843264687', 'product_description': 'Top Product 1', 'quantity_sold': Decimal('5.000')}, {'product_id': 14, 'product_code': 'TOP2_1752843264689', 'product_description': 'Top Product 2', 'quantity_sold': Decimal('3.000')}, {'product_id': 1, 'product_code': 'P001', 'product_description': 'Test Product', 'quantity_sold': Decimal('2.000')}, {'product_id': 15, 'product_code': 'TOP3_1752843264693', 'product_description': 'Top Product 3', 'quantity_sold': Decimal('1.000')}])
FAILED tests/infrastructure/persistence/test_sale_repository.py::test_calculate_profit_for_period - assert 290.0 == 90.0
FAILED tests/infrastructure/persistence/test_sale_repository.py::test_get_sales_by_period_filtering - AssertionError: assert 4 == 3
 +  where 4 = len([Sale(id=4, timestamp=datetime.datetime(2025, 7, 18, 14, 54, 24, 782639), items=[SaleItem(product_id=19, quantity=Decimal('1.000'), unit_price=Decimal('10.00'), id=4, sale_id=4, product_code='PERIOD_1752843264780', product_description='Period Test Product')], customer_id=UUID('b5163b78-97d9-4a5a-81e9-533d65b2a038'), is_credit_sale=False, user_id=1, payment_type='CASH'), Sale(id=1, timestamp=datetime.datetime(2025, 7, 18, 14, 54, 21, 108824), items=[SaleItem(product_id=1, quantity=Decimal('2.000'), unit_price=Decimal('100.00'), id=1, sale_id=1, product_code='P001', product_description='Test Product')], customer_id=UUID('9744baa8-02f4-4a69-af1d-1cb51052aa4f'), is_credit_sale=False, user_id=None, payment_type='cash'), Sale(id=3, timestamp=datetime.datetime(2025, 7, 17, 14, 54, 24, 782639), items=[SaleItem(product_id=19, quantity=Decimal('1.000'), unit_price=Decimal('10.00'), id=3, sale_id=3, product_code='PERIOD_1752843264780', product_description='Period Test Product')], customer_id=UUID('b5163b78-97d9-4a5a-81e9-533d65b2a038'), is_credit_sale=False, user_id=1, payment_type='CARD'), Sale(id=2, timestamp=datetime.datetime(2025, 7, 16, 14, 54, 24, 782639), items=[SaleItem(product_id=19, quantity=Decimal('1.000'), unit_price=Decimal('10.00'), id=2, sale_id=2, product_code='PERIOD_1752843264780', product_description='Period Test Product')], customer_id=UUID('b5163b78-97d9-4a5a-81e9-533d65b2a038'), is_credit_sale=False, user_id=1, payment_type='CASH')])
FAILED tests/infrastructure/persistence/test_sale_repository_fixed.py::test_calculate_profit_for_period - assert 290.0 == 90.0
FAILED tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_transaction_commit - sqlalchemy.exc.ResourceClosedError: This Connection is closed
FAILED tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_transaction_rollback - sqlalchemy.exc.ResourceClosedError: This Connection is closed
FAILED tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_manual_commit - sqlalchemy.exc.ResourceClosedError: This Connection is closed
FAILED tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_manual_rollback - sqlalchemy.exc.ResourceClosedError: This Connection is closed
FAILED tests/infrastructure/persistence/test_unit_of_work.py::TestUnitOfWork::test_unit_of_work_complex_operation - sqlalchemy.exc.ResourceClosedError: This Connection is closed
FAILED tests/integration/test_db_simple.py::test_simple_db_session - AssertionError: Test user should have correct username
assert 'clean_db_testuser_c536a3a0' == 'testuser'
  
  - testuser
  + clean_db_testuser_c536a3a0
FAILED tests/integration/test_end_to_end_flows.py::TestSalesEndToEndFlow::test_complete_sale_process - ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.
FAILED tests/integration/test_end_to_end_flows.py::TestSalesEndToEndFlow::test_sale_with_error_handling - ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.
FAILED tests/integration/test_end_to_end_flows.py::TestInvoicingEndToEndFlow::test_invoice_generation_from_sale - ValueError: Customer with CUIT 20-12345678-9 already exists
FAILED tests/integration/test_end_to_end_flows.py::TestConcurrencyAndEdgeCases::test_simple_product_creation - ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.
FAILED tests/integration/test_user_integration.py::TestUserIntegration::test_add_user_valid_user_returns_user - ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.
FAILED tests/integration/test_user_integration.py::TestUserIntegration::test_add_user_duplicate_username_raises_value_error - ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.
FAILED tests/integration/test_user_integration.py::TestUserIntegration::test_authenticate_user_valid_credentials_returns_user - ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.
FAILED tests/integration/test_user_integration.py::TestUserIntegration::test_authenticate_user_invalid_credentials_returns_none - ValueError: No session factory has been set. Make sure to call session_scope_provider.set_default_session_factory() first.
ERROR tests/infrastructure/persistence/test_inventory_repository.py::test_get_movements_for_product - ValueError: Product code 'TESTPROD' already exists.
ERROR tests/infrastructure/persistence/test_inventory_repository.py::test_get_all_movements - ValueError: Product code 'TESTPROD' already exists.
ERROR tests/infrastructure/persistence/test_product_repository.py::test_delete_product - ValueError: Department name 'Testing Dept' already exists.
ERROR tests/infrastructure/persistence/test_product_repository.py::test_search_product - ValueError: Department name 'Testing Dept' already exists.
ERROR tests/infrastructure/persistence/test_product_repository.py::test_update_stock - ValueError: Department name 'Testing Dept' already exists.
ERROR tests/infrastructure/persistence/test_product_repository.py::test_get_low_stock - ValueError: Department name 'Testing Dept' already exists.
ERROR tests/infrastructure/persistence/test_product_repository.py::test_get_all_products_filtered_and_paginated - ValueError: Department name 'Testing Dept' already exists.
ERROR tests/infrastructure/persistence/test_product_repository.py::test_get_all_products_sorting - ValueError: Department name 'Testing Dept' already exists.
ERROR tests/integration/test_invoicing_integration.py::TestInvoicingIntegration::test_create_invoice_from_sale - ValueError: Customer with CUIT 20123456789 already exists
ERROR tests/integration/test_invoicing_integration.py::TestInvoicingIntegration::test_get_all_invoices - ValueError: Customer with CUIT 20123456789 already exists
ERROR tests/integration/test_invoicing_integration.py::TestInvoicingIntegration::test_generate_invoice_pdf - ValueError: Customer with CUIT 20123456789 already exists
============ 29 failed, 584 passed, 1 warning, 11 errors in 16.40s ============
